/*
 * Created on 13 May 2016 ( Time 13:32:21 )
 * Generated by Telosys Tools Generator ( version 2.1.1 )
 */
package com.abm.mainet.water.service;

import java.io.IOException;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.sql.Timestamp;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collector;
import java.util.stream.Collectors;

import javax.annotation.Resource;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.collections.MapUtils;
import org.apache.commons.lang.StringUtils;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.abm.mainet.bill.dto.BillGenErrorMapDTO;
import com.abm.mainet.bill.dto.WaterBillGenerationMap;
import com.abm.mainet.bill.repository.AdjustmentEntryRepository;
import com.abm.mainet.bill.service.AdjustmentEntryService;
import com.abm.mainet.bill.service.BillDetailsService;
import com.abm.mainet.bill.service.BillMasterCommonService;
import com.abm.mainet.cfc.challan.domain.AdjustmentBillDetailMappingEntity;
import com.abm.mainet.cfc.challan.domain.AdjustmentMasterEntity;
import com.abm.mainet.cfc.challan.service.IChallanService;
import com.abm.mainet.cfc.loi.domain.TbLoiDetEntity;
import com.abm.mainet.cfc.loi.dto.TbLoiMas;
import com.abm.mainet.cfc.loi.service.TbLoiDetService;
import com.abm.mainet.cfc.loi.service.TbLoiMasService;
import com.abm.mainet.common.audit.service.AuditService;
import com.abm.mainet.common.constant.MainetConstants;
import com.abm.mainet.common.constant.PrefixConstants;
import com.abm.mainet.common.constant.PrefixConstants.NewWaterServiceConstants;
import com.abm.mainet.common.constant.ServiceEndpoints;
import com.abm.mainet.common.domain.FinancialYear;
import com.abm.mainet.common.domain.Organisation;
import com.abm.mainet.common.domain.ServiceMaster;
import com.abm.mainet.common.dto.DuplicateBillDTO;
import com.abm.mainet.common.dto.HolidayMasterDto;
import com.abm.mainet.common.exception.FrameworkException;
import com.abm.mainet.common.integration.acccount.domain.TbServiceReceiptMasEntity;
import com.abm.mainet.common.integration.dms.client.FileNetApplicationClient;
import com.abm.mainet.common.integration.dto.BillTaxDTO;
import com.abm.mainet.common.integration.dto.TbBillDet;
import com.abm.mainet.common.integration.dto.TbBillMas;
import com.abm.mainet.common.integration.dto.WSRequestDTO;
import com.abm.mainet.common.integration.dto.WSResponseDTO;
import com.abm.mainet.common.master.dto.TbTaxMas;
import com.abm.mainet.common.master.service.DepartmentService;
import com.abm.mainet.common.master.service.HolidayMasterService;
import com.abm.mainet.common.master.service.TbFinancialyearService;
import com.abm.mainet.common.master.service.TbTaxMasService;
import com.abm.mainet.common.service.IDuplicateBillService;
import com.abm.mainet.common.service.IFinancialYearService;
import com.abm.mainet.common.service.IReceiptEntryService;
import com.abm.mainet.common.service.ServiceMasterService;
import com.abm.mainet.common.utility.ApplicationContextProvider;
import com.abm.mainet.common.utility.ApplicationSession;
import com.abm.mainet.common.utility.CommonMasterUtility;
import com.abm.mainet.common.utility.LookUp;
import com.abm.mainet.common.utility.RestClient;
import com.abm.mainet.common.utility.Utility;
import com.abm.mainet.smsemail.dto.SMSAndEmailDTO;
import com.abm.mainet.smsemail.service.ISMSAndEmailService;
import com.abm.mainet.water.dao.DemandNoticeGenarationRepository;
import com.abm.mainet.water.dao.TbMrdataJpaRepository;
import com.abm.mainet.water.dao.WaterErrorTableDAO;
import com.abm.mainet.water.datamodel.NoOfDays;
import com.abm.mainet.water.datamodel.WaterRateMaster;
import com.abm.mainet.water.datamodel.WaterTaxCalculation;
import com.abm.mainet.water.domain.DemandNotice;
import com.abm.mainet.water.domain.TbKCsmrInfoMH;
import com.abm.mainet.water.domain.TbMrdataEntity;
import com.abm.mainet.water.domain.TbWtBIllDetHist;
import com.abm.mainet.water.domain.TbWtBIllMasHist;
import com.abm.mainet.water.domain.TbWtBillDetEntity;
import com.abm.mainet.water.domain.TbWtBillGenError;
import com.abm.mainet.water.domain.TbWtBillMasEntity;
import com.abm.mainet.water.domain.TbWtExcessAmt;
import com.abm.mainet.water.domain.WaterPenaltyEntity;
import com.abm.mainet.water.domain.WaterPenaltyHistoryEntity;
import com.abm.mainet.water.dto.MeterReadingDTO;
import com.abm.mainet.water.dto.TbCsmrInfoDTO;
import com.abm.mainet.water.dto.TbMeterMas;
import com.abm.mainet.water.dto.TbWtBillSchedule;
import com.abm.mainet.water.dto.TbWtBillScheduleDetail;
import com.abm.mainet.water.dto.WaterBillGenErrorDTO;
import com.abm.mainet.water.dto.WaterBillPrintSkdclDTO;
import com.abm.mainet.water.dto.WaterBillPrintingDTO;
import com.abm.mainet.water.dto.WaterBillTaxDTO;
import com.abm.mainet.water.dto.WaterPenaltyDto;
import com.abm.mainet.water.repository.BillMasterJpaRepository;
import com.abm.mainet.water.repository.TbCsmrInfoRepository;
import com.abm.mainet.water.repository.TbWtBillDetJpaRepository;
import com.abm.mainet.water.repository.TbWtBillMasJpaRepository;
import com.abm.mainet.water.repository.TbWtExcessAmtJpaRepository;
import com.abm.mainet.water.repository.WaterPenaltyRepository;
import com.abm.mainet.water.rest.dto.WaterBillRequestDTO;
import com.abm.mainet.water.utility.NumberToWordsConverter;
import com.abm.mainet.water.utility.WaterCommonUtility;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.util.concurrent.AtomicDouble;

/**
 * Implementation of TbWtBillMasService
 */
@Service
public class TbWtBillMasServiceImpl implements TbWtBillMasService {

    private static final Logger LOGGER = LoggerFactory.getLogger(TbWtBillMasServiceImpl.class);

    @Resource
    private TbWtBillMasJpaRepository tbWtBillMasJpaRepository;

    @Resource
    private TbWtBillDetJpaRepository tbWtBillDetJpaRepository;

    @Resource
    private WaterErrorTableDAO waterErrorTableDAO;

    @Autowired
    private TbMrdataService tbMrdataService;

    @Resource
    private TbMrdataJpaRepository tbMrdataJpaRepository;

    @Autowired
    private TbMeterMasService tbMeterMasService;

    @Autowired
    private DemandNoticeGenarationRepository demandNoticeGenarationRepository;

    @Autowired
    private TbWtBillScheduleService tbWtBillScheduleService;

    @Resource
    private MeterCutOffRestorationService meterCutOffRestorationService;

    @Resource
    private BillMasterService billMasterService;

    @Resource
    private AuditService auditService;

    @Resource
    private IChallanService iChallanService;

    @Resource
    private TbWtExcessAmtJpaRepository tbWtExcessAmtJpaRepository;

    @Resource
    private WaterExceptionalGapService waterExceptionalGapService;

    @Autowired
    private DepartmentService departmentService;

    @Autowired
    private TbTaxMasService tbTaxMasService;

    @Autowired
    private AdjustmentEntryService adjustmentService;

    @Autowired
    private IFinancialYearService iFinancialYearService;

    @Resource
    private BillMasterJpaRepository billMasterJpaRepository;

    @Autowired
    private ISMSAndEmailService ismsAndEmailService;

    @Autowired
    private IDuplicateBillService duplicateBillService;

    @Autowired
    IWaterPenaltyService waterPenaltyService;

    @Autowired
    private WaterCommonService waterCommonService;

    @Autowired
    private TbLoiMasService tbLoiMasService;

    @Autowired
    ServiceMasterService serviceMaster;
    
    @Autowired
    HolidayMasterService holidayMasterService;
	@Resource
	private WaterPenaltyRepository waterPenaltyRepository;

	@Autowired
	private IReceiptEntryService iReceiptEntryService;
	
	@Autowired
    private TbFinancialyearService tbFinancialyearService;

	@Autowired
	private TbMrdataJpaRepository meterReadingRepository;
	
	@Autowired
	private TbCsmrInfoRepository csmrInfoReposiory;
	
	private final Long STD_DUE_DATE = 90 * 24 * 60 * 60  * 1000l;
	
	@Autowired
	AdjustmentEntryRepository adjustmentRepository;
	
	@Resource
	private BillMasterCommonService billMasterCommonService;
	
	@Autowired
	NewWaterConnectionService newWaterConnectionService;
	
	@Autowired
	TbMeterMasService tbMasService; 
	
    @Override
    public TbBillMas update(final TbBillMas tbWtBillMas) {
        final TbWtBillMasEntity tbWtBillMasEntity = tbWtBillMasJpaRepository.findOne(tbWtBillMas.getBmIdno());
        BeanUtils.copyProperties(tbWtBillMas, tbWtBillMasEntity);
        TbBillDet detDto = null;
        final List<TbBillDet> detList = new ArrayList<>(0);
        List<TbWtBillDetEntity> billDetEntity = new ArrayList<>(0);
        for (final TbBillDet det : tbWtBillMas.getTbWtBillDet()) {
            detDto = new TbBillDet();
            final TbWtBillDetEntity tbWtBillDetEntity = new TbWtBillDetEntity();
            BeanUtils.copyProperties(det, tbWtBillDetEntity);
            det.setBmIdno(tbWtBillMasEntity.getBmIdno());
            tbWtBillDetEntity.setBmIdNo(tbWtBillMasEntity);
            detList.add(detDto);
            billDetEntity.add(tbWtBillDetEntity);
        }
        tbWtBillMasEntity.setBillDetEntity(billDetEntity);
        final TbWtBillMasEntity tbWtBillMasEntitySaved = tbWtBillMasJpaRepository.save(tbWtBillMasEntity);
        final TbBillMas billmas = new TbBillMas();
        BeanUtils.copyProperties(tbWtBillMasEntitySaved, billmas);
        billmas.setTbWtBillDet(detList);
        return billmas;
    }

    /*
     * (non-Javadoc)
     * @see com.abm.mainetservice.water.service.TbWtBillMasService#getBillMaster( java.lang.Long, long)
     */
    @Override
    @Transactional(readOnly = true)
    public TbBillMas getBillMaster(final Long csIdn, final long orgid, final Date billFrom, final Date billTo) {
        TbBillMas billmas = new TbBillMas();
        final List<TbWtBillMasEntity> tbWtBillMasEntity = tbWtBillMasJpaRepository
                .getBillMasterbyCsidnFromDateToDAte(csIdn, orgid, billFrom, billTo);
        if ((tbWtBillMasEntity != null) && !tbWtBillMasEntity.isEmpty()) {
            BeanUtils.copyProperties(tbWtBillMasEntity, billmas);
        }
        return billmas;
    }

    /*
     * (non-Javadoc)
     * @see com.abm.mainet.water.service.TbWtBillMasService#insertIntoErrorTable (com.abm.mainet.water.dto.WaterBillGenErrorDTO)
     */
    @Override
    @Transactional
    public void insertIntoErrorTable(final WaterBillGenErrorDTO errorDto) {
        final TbWtBillGenError error = new TbWtBillGenError();
        error.setCsIdn(errorDto.getCsIdn());
        error.setErrDate(errorDto.getErrDate());
        error.setErrMsg(errorDto.getErrMsg());
        error.setOrgId(errorDto.getOrgId());
        error.setUserId(errorDto.getUserId());
        waterErrorTableDAO.saveErrorRecords(error);
    }

    /*
     * (non-Javadoc)
     * @see com.abm.mainet.water.service.TbWtBillMasService#getBillPrintingData (java.util.List)
     */
    @Override
    @Transactional(readOnly = true)
    public List<Object[]> getBillPrintingData(final List<Long> billPrintIds, final Organisation organisation) {
    	List<Object[]> result = null;
    	if(Utility.isEnvPrefixAvailable(organisation, MainetConstants.ENV_SKDCL)) {
    		result = tbWtBillMasJpaRepository.getBillPrintingDataForSkdcl(billPrintIds, organisation.getOrgid());
    	}else{
    		result = tbWtBillMasJpaRepository.getBillPrintingData(billPrintIds, organisation.getOrgid());
    	}
        return result;

    }

    /*
     * (non-Javadoc)
     * @see com.abm.mainet.water.service.TbWtBillMasService#prinBillData(java .util.Map)
     */
    @Override
    @Transactional(readOnly = true)
    public Map<Long, WaterBillPrintingDTO> prinBillData(final Map<Long, WaterBillPrintingDTO> billMasPrint,
            final Organisation organisation, final List<String> billIds, final String meterType,
            final FileNetApplicationClient fileNetApplicationClient,List<TbTaxMas> taxesMaster,Long applicationNo, String billGenGlag,Long surchargeTaxId) {
        
    	LOGGER.info("Begin--> " + this.getClass().getSimpleName() + " prinBillData() method ");
    	final List<Long> billPrintIds = new ArrayList<>(0);
        final List<Long> conIds = new ArrayList<>(0);
        for (final String id : billIds) {
            billPrintIds.add(Long.valueOf(id.trim()));
        }
        LOGGER.info("billPrintIds size is : "+billPrintIds.size());
        final HashMap<Long, String> taxDesc = new HashMap<>(0);
		/*
		 * final Long deptId =
		 * departmentService.getDepartmentIdByDeptCode(MainetConstants.
		 * WATER_DEPARTMENT_CODE, MainetConstants.STATUS.ACTIVE); final LookUp
		 * chargeApplicableAt = CommonMasterUtility.getValueFromPrefixLookUp(
		 * PrefixConstants.NewWaterServiceConstants.BILL,
		 * PrefixConstants.NewWaterServiceConstants.CAA, organisation);
		 */

        /**
         * To Get All the taxes i.e. Active and Inactive Taxes At Bill Printing
         */
        /*
         * final List<TbTaxMas> taxesMaster = tbTaxMasService.findAllTaxesForBillGeneration(organisation.getOrgid(), deptId,
         * chargeApplicableAt.getLookUpId(), null);
         */

		/*
		 * final List<TbTaxMas> taxesMaster =
		 * tbTaxMasService.findAllTaxesForBillPayment(organisation.getOrgid(), deptId,
		 * chargeApplicableAt.getLookUpId());
		 * 
		 * final List<TbTaxMas> taxesMasterBillReceipt =
		 * tbTaxMasService.findAllTaxesForBillPayment(organisation.getOrgid(), deptId,
		 * chargeApplicableAtBillAndReceipt.getLookUpId());
		 * taxesMaster.addAll(taxesMasterBillReceipt);
		 */

        if ((taxesMaster != null) && !taxesMaster.isEmpty()) {
            for (final TbTaxMas tax : taxesMaster) {
                taxDesc.put(tax.getTaxId(), tax.getTaxDesc());
            }
        }
        final List<Object[]> billMasList = getBillPrintingData(billPrintIds, organisation);
        LOGGER.info("BillMasList size after getBillPrintingData() method is : "+billMasList.size());
        final List<TbBillDet> billDetList = getBillDetailEntity(billPrintIds, organisation.getOrgid());
        LOGGER.info("billDetList size after getBillDetailEntity() method is : "+billDetList.size());
        if ((billMasList != null) && !billMasList.isEmpty()) {
            WaterBillPrintingDTO bill = null;

            for (final Object[] billMas : billMasList) {
                bill = new WaterBillPrintingDTO();
                StringBuilder securityDeposit = new StringBuilder();
                bill.setBmTotalOutstanding(0d);
                bill.setBmIdno(Long.valueOf(billMas[0].toString()));
                if (billMas[1] != null) {
                    bill.getWaterMas().setCsCcn(billMas[1].toString());
                }
                if (billMas[2] != null) {
                    final String conCategory = CommonMasterUtility.getCPDDescription(
                            Long.valueOf(billMas[2].toString()), PrefixConstants.D2KFUNCTION.ENGLISH_DESC,
                            organisation.getOrgid());
                    bill.setConnectionCategory(conCategory);
                }
                if (billMas[3] != null) {
                    final String conSize = CommonMasterUtility.getCPDDescription(Long.valueOf(billMas[3].toString()),
                            PrefixConstants.D2KFUNCTION.ENGLISH_DESC, organisation.getOrgid());
                    bill.setConSize(conSize);
                }
                if (billMas[4] != null) {
                    final LookUp tariffCategory = CommonMasterUtility.getHierarchicalLookUp(
                            Long.valueOf(billMas[4].toString()), organisation.getOrgid());
                    bill.setTarriffCategory(tariffCategory.getDescLangFirst());
                }
                if (billMas[5] != null) {
                    bill.getWaterMas().setCsFlatno(billMas[5].toString());
                }
                if (billMas[6] != null) {
                    bill.getWaterMas().setCsName(billMas[6].toString());
                }
                if (billMas[7] != null) {
                    bill.getWaterMas().setCsMname(billMas[7].toString());
                }
                if (billMas[8] != null) {
                    bill.getWaterMas().setCsLname(billMas[8].toString());
                }
                if (billMas[9] != null) {
                    bill.getWaterMas().setCsAdd(billMas[9].toString());
                }
                if (billMas[10] != null) {
                    bill.getWaterMas().setCsFlatno(billMas[10].toString());
                }
                if (billMas[11] != null) {
                    bill.getWaterMas().setCsBldplt(billMas[11].toString());
                }
                if (billMas[12] != null) {
                    bill.getWaterMas().setCsLanear(billMas[12].toString());
                }
                if (billMas[13] != null) {
                    bill.getWaterMas().setCsRdcross(billMas[13].toString());
                }
                if (billMas[14] != null) {
                    bill.setBmBilldt((Date) billMas[14]);
                }
                if (billMas[15] != null) {
                    bill.setBmFromdt((Date) billMas[15]);
                }
                if (billMas[16] != null) {
                    bill.setBmTodt((Date) billMas[16]);
                }
                if (billMas[17] != null) {
                    bill.setBmDuedate((Date) billMas[17]);
                }

                if (billMas[19] != null) {
                    bill.getWaterMas().setCsBadd(billMas[19].toString());
                }
                if (billMas[20] != null) {
                    bill.getWaterMas().setCsBbldplt(billMas[20].toString());
                }
                if (billMas[21] != null) {
                    bill.getWaterMas().setCsBlanear(billMas[21].toString());
                }
                if (billMas[22] != null) {
                    bill.getWaterMas().setCsBrdcross(billMas[22].toString());
                }
                bill.getWaterMas().setCsIdn(Long.valueOf(billMas[23].toString()));
                conIds.add(Long.valueOf(billMas[23].toString()));
                if (billMas[24] != null) {
                    bill.getWaterMas().setPropertyNo(billMas[24].toString());
                }
                if (billMas[25] != null) {
                    bill.setBmNo(billMas[25].toString());
                }
                if (billMas[26] != null) {
                    bill.setBmRemarks(billMas[26].toString());
                }
                if (billMas[27] != null) {
                    if (billMas[27].toString().equals(MainetConstants.FlagP))
                        bill.setConnectionCategory("Permanent");
                    else
                        bill.setConnectionCategory("Temporary");
                }
                if (billMas[28] != null) {
                    bill.setBmYear(Long.valueOf(billMas[28].toString()));
                }
                if (billMas[29] != null) {
                    if (billMas[29].toString().equals(MainetConstants.FlagY))
                        bill.setBplFlag(MainetConstants.YES);
                    else
                        bill.setBplFlag(MainetConstants.NO);
                }
                if (billMas[30] != null) {
                    securityDeposit.append(billMas[30].toString());
                } else {
                    if (billMas[1] != null) {
                    	Long applicationId = 0L;
                    	if(StringUtils.isBlank(billGenGlag)) {
                    		   TbKCsmrInfoMH infoMas = waterCommonService
                                       .fetchConnectionDetailsByConnNo(bill.getWaterMas().getCsCcn(), organisation.getOrgid());
                    		   applicationId = infoMas.getApplicationNo();
                    	}else if(StringUtils.isNotBlank(billGenGlag) && StringUtils.equals(billGenGlag, MainetConstants.FlagY)){
                    		applicationId = applicationNo;
                    	}
                        final ServiceMaster service = serviceMaster.getServiceByShortName(
                                PrefixConstants.NewWaterServiceConstants.WNC, organisation.getOrgid());
                        List<TbLoiMas> loimas = tbLoiMasService.getloiByApplicationId(applicationId,
                                service.getSmServiceId(), organisation.getOrgid());
						
                        if (!CollectionUtils.isEmpty(loimas)) {
                        	List<TbLoiDetEntity> loiDetList = ApplicationContextProvider.getApplicationContext().getBean(TbLoiDetService.class)
    								.findLoiDetailsByLoiIdAndOrgId(loimas.get(0).getLoiId(), loimas.get(0).getOrgid());
                        	if(CollectionUtils.isNotEmpty(loiDetList)) {
                        		loiDetList.forEach( loiDet ->{
                        			TbTaxMas loiDetTax = tbTaxMasService.findById(loiDet.getLoiChrgid(),
        									organisation.getOrgid());
                        			final String taxCategoryCode = CommonMasterUtility
        									.getHierarchicalLookUp(loiDetTax.getTaxCategory1(), organisation).getLookUpCode();
                        			final String taxSubCategoryCode = CommonMasterUtility
        									.getHierarchicalLookUp(loiDetTax.getTaxCategory2(), organisation).getLookUpCode();
                        			if(StringUtils.equals(taxCategoryCode, "DPT") && StringUtils.equals(taxSubCategoryCode, "SD")) {
                        				securityDeposit.append(String.valueOf(loiDet.getLoiAmount()));
                        			}
                        			
                        		});
                        	}
                            securityDeposit.append(MainetConstants.WHITE_SPACE);
                            securityDeposit.append(MainetConstants.WINDOWS_SLASH);
                            securityDeposit.append(MainetConstants.WHITE_SPACE);
                            securityDeposit.append(loimas.get(0).getLoiNo());
                            SimpleDateFormat date = new SimpleDateFormat(MainetConstants.DATE_FORMAT);
                            if (billMas[30] == null) {
                                securityDeposit.append(MainetConstants.WHITE_SPACE);
                                securityDeposit.append(MainetConstants.WINDOWS_SLASH);
                                securityDeposit.append(MainetConstants.WHITE_SPACE);
                                securityDeposit.append(date.format((Date) loimas.get(0).getLoiDate()));
                            }
                        }
                    }
                }
                if (billMas[31] != null) {
                    SimpleDateFormat date = new SimpleDateFormat(MainetConstants.DATE_FORMAT);
                    if (billMas[30] != null)
                        securityDeposit.append(MainetConstants.WINDOWS_SLASH);
                    securityDeposit.append(date.format((Date) billMas[17]));
                }
                if (securityDeposit.length() > 0) {
                    bill.setSecurityDepositAmount(securityDeposit.toString());
                }
                if (billMas[32] != null) {
                    bill.getWaterMas().setCsCpinCode(Long.valueOf(billMas[32].toString()));
                }
                if (billMas[33] != null) {
                    bill.getWaterMas().setHouseNumber(billMas[33].toString());
                }
                if(billMas[0] != null) {
                	             		               	
                	// This code is added because edited interest as surcharge and we added this interest alias surcharge to actual surcharge.
                	 LookUp taxCategoryLookUp = CommonMasterUtility.getHieLookupByLookupCode("P",
                             PrefixConstants.LookUpPrefix.TAC, 1, organisation.getOrgid());
					/*
					 * LookUp taxSubCategoryLookUp =
					 * CommonMasterUtility.getHieLookupByLookupCode("SC",
					 * PrefixConstants.LookUpPrefix.TAC, 2, organisation.getOrgid());
					 */
					//Long taxId=tbTaxMasService.getTaxId(chargeApplicableAt.getLookUpId(), organisation.getOrgid(), deptId, taxCategoryLookUp.getLookUpId(), taxSubCategoryLookUp.getLookUpId());
					
					Optional<TbBillDet> findFirst = billDetList.stream()
							.filter(detail -> detail.getTaxId().equals(surchargeTaxId)).findFirst();

					if (Utility.isEnvPrefixAvailable(organisation, MainetConstants.ENV_SKDCL)) {
						List<WaterPenaltyEntity> penaltyList = waterPenaltyRepository
								.getWaterPenaltyByCCnNo(billMas[23].toString(), organisation.getOrgid());
						double sumOfPenalty = 0.0;
						for (WaterPenaltyEntity penalty : penaltyList) {
							sumOfPenalty += Math.round(penalty.getPendingAmount());
						}

						if (findFirst.isPresent()) {
							for (TbBillDet detail : billDetList) {
								final String taxCode = CommonMasterUtility
										.getHierarchicalLookUp(detail.getTaxCategory(), organisation).getLookUpCode();
								if (StringUtils.equals(taxCode, "P")) {
									if (CollectionUtils.isNotEmpty(penaltyList)) {
										detail.setBdCurTaxamt(Math.round(detail.getBdCurTaxamt() + sumOfPenalty));
										detail.setBdCurBalTaxamt(Math.round(detail.getBdCurBalTaxamt() + sumOfPenalty));
									}
								}
							}
						} else {
							if (CollectionUtils.isNotEmpty(penaltyList)) {
								TbBillDet det = new TbBillDet();
								det.setTaxId(penaltyList.get(0).getTaxId());
								det.setBdCurTaxamt(Math.round(sumOfPenalty));
//								det.setBdCurBalTaxamt(sumOfPenalty);
								det.setBmIdno(Long.valueOf(billMas[0].toString()));
								det.setOrgid(organisation.getOrgid());
								det.setBdPrvBalArramt(Math.round(sumOfPenalty));
								/*
								 * TbTaxMas surchargeTaxMast =
								 * tbTaxMasService.findById(waterPenaltyDto.getTaxId(),
								 * organisation.getOrgid());
								 */
								det.setTaxCategory(taxCategoryLookUp.getLookUpId());
								billDetList.add(det);
							}
						}

					} else {
						WaterPenaltyDto waterSurchargeDto = ApplicationContextProvider.getApplicationContext()
								.getBean(IWaterPenaltyService.class)
								.getWaterPenaltyByCCNOByFinId(String.valueOf(billMas[23]), 0L, organisation.getOrgid());

						if (findFirst.isPresent()) {
							for (TbBillDet detail : billDetList) {
								final String taxCode = CommonMasterUtility
										.getHierarchicalLookUp(detail.getTaxCategory(), organisation).getLookUpCode();
								if (StringUtils.equals(taxCode, "P")) {
									if (waterSurchargeDto != null) {
										detail.setBdCurTaxamt(Math.round(
												detail.getBdCurTaxamt() + waterSurchargeDto.getPendingAmount()));
										detail.setBdCurBalTaxamt(Math.round(
												detail.getBdCurBalTaxamt() + waterSurchargeDto.getPendingAmount()));
									}
								}
							}
						} else {
							if (waterSurchargeDto != null) {
								TbBillDet det = new TbBillDet();
								det.setTaxId(waterSurchargeDto.getTaxId());
								det.setBdCurTaxamt(Math.round(waterSurchargeDto.getPendingAmount()));
								det.setBdCurBalTaxamt(Math.round(waterSurchargeDto.getPendingAmount()));
								det.setBmIdno(Long.valueOf(billMas[0].toString()));
								det.setOrgid(waterSurchargeDto.getOrgId());
								/*
								 * TbTaxMas surchargeTaxMast =
								 * tbTaxMasService.findById(waterPenaltyDto.getTaxId(),
								 * organisation.getOrgid());
								 */
								det.setTaxCategory(taxCategoryLookUp.getLookUpId());
								billDetList.add(det);
							}
						}
					}
                    	
               
                
                }
                billMasPrint.put(Long.valueOf(billMas[0].toString()), bill);
            }
        }

        Map<Long, TbMeterMas> meterData = null;
        Map<Long, MeterReadingDTO> meterReading = null;
        if (MainetConstants.NewWaterServiceConstants.METER.equals(meterType)) {
            meterData = tbMeterMasService.findMeterMasListBycnsId(conIds, organisation.getOrgid());
            meterReading = tbMrdataService.findMeterReadingByCsidnAndOrgid(conIds, organisation,
                    fileNetApplicationClient);
        }

        Map<Long, BigDecimal> excessAmountMap = null;
        Map<Long, BigDecimal> excessAdjustAmountMap = null;
        final List<Object[]> excessAmount = tbWtExcessAmtJpaRepository.fetchExcessAmountDataForPrinting(conIds,
                organisation.getOrgid());
        if ((excessAmount != null) && !excessAmount.isEmpty()) {
            excessAmountMap = new HashMap<>(0);
            excessAdjustAmountMap = new HashMap<>(0);
            for (final Object[] entity : excessAmount) {
                BigDecimal amount = new BigDecimal(entity[1].toString());
                amount.setScale(2, RoundingMode.HALF_UP);
                BigDecimal adjustAmount = new BigDecimal(entity[2].toString());
                adjustAmount.setScale(2, RoundingMode.HALF_UP);
                excessAmountMap.put(Long.valueOf(entity[0].toString()), amount);
                excessAdjustAmountMap.put(Long.valueOf(entity[0].toString()), adjustAmount);
                
            }
        }
        if ((billDetList != null) && !billDetList.isEmpty()) {
            WaterBillPrintingDTO billData = null;
            MeterReadingDTO meter = null;
            LookUp taxCode = null;
            String lookString = null;
            for (final TbBillDet billDet : billDetList) {
                billData = billMasPrint.get(billDet.getBmIdno());
                if (billData != null) {
                    taxCode = CommonMasterUtility.getHierarchicalLookUp(billDet.getTaxCategory(), organisation);
                    lookString = taxCode.getLookUpCode();
                    if (!lookString.equals(PrefixConstants.TAX_CATEGORY.ADVANCE)
                            && !lookString.equals(PrefixConstants.TAX_CATEGORY.REBATE)) {
                        billDet.setTaxDesc(taxDesc.get(billDet.getTaxId()));
                        billDet.setTotal(Math.round(billDet.getBdPrvBalArramt() + billDet.getBdCurBalTaxamt()));
                        billData.setArrearsTotal(Math.round(billData.getArrearsTotal() + billDet.getBdPrvBalArramt()));
                        billData.setTaxtotal(Math.round(billData.getTaxtotal() + billDet.getBdCurBalTaxamt()));
                        billData.setGrandTotal(Math.round(billData.getArrearsTotal() + billData.getTaxtotal()));
                        billData.setBmTotalOutstanding(Math.round(
                                billDet.getBdPrvBalArramt() + billDet.getBdCurBalTaxamt() + billData.getBmTotalOutstanding()));
                        billData.getTbWtBillDet().add(billDet);

                    } else if (lookString.equals(PrefixConstants.TAX_CATEGORY.ADVANCE)) {
                        billData.setExcessAmount(Math.round(billData.getExcessAmount() + billDet.getBdCurTaxamt()));
                    } else if (lookString.equals(PrefixConstants.TAX_CATEGORY.REBATE)) {
                        billData.setRebateAmount(Math.round(billData.getRebateAmount() + billDet.getBdCurTaxamt()));
                    }
                    if ((meterData != null) && !meterData.isEmpty()) {
                        billData.setMeterMas(meterData.get(billData.getWaterMas().getCsIdn()));
                    }
                    if ((meterReading != null) && !meterReading.isEmpty()) {
                        meter = meterReading.get(billData.getWaterMas().getCsIdn());
                        billData.setMeterRead(meter);
                    }
                    if ((excessAmountMap != null) && !excessAmountMap.isEmpty()) {
                        final BigDecimal amount = excessAmountMap.get(billData.getWaterMas().getCsIdn());
                        if (amount != null) {
                            billData.setBalanceExcessAmount(amount);
                        } else {
                            billData.setBalanceExcessAmount(BigDecimal.valueOf(0.00));
                        }
                    } else {
                        billData.setBalanceExcessAmount(BigDecimal.valueOf(0.00));
                    }
                    if ((excessAdjustAmountMap != null) && !excessAdjustAmountMap.isEmpty()) {
                        final BigDecimal amount = excessAdjustAmountMap.get(billData.getWaterMas().getCsIdn());
                        if (amount != null) {
                            billData.setExcessAmount(amount.doubleValue());
                        } else {
                            billData.setExcessAmount(BigDecimal.valueOf(0.00).doubleValue());
                        }
                    } else {
                        billData.setExcessAmount(BigDecimal.valueOf(0.00).doubleValue());
                    }
                    final String amountInWords = Utility
                            .convertBiggerNumberToWord(BigDecimal.valueOf(billData.getBmTotalOutstanding()));
                    billData.setAmountInwords(amountInWords);
                    billData.setBmTotalOutstanding(Math.round(billData.getBmTotalOutstanding()));
                }
            }
        }
        LOGGER.info("END--> " + this.getClass().getSimpleName() + " prinBillData() method ");
        return billMasPrint;
    }

    @Override
    public List<TbBillDet> getBillDetailEntity(List<Long> billPrintIds, long orgid) {
        final Iterable<TbWtBillDetEntity> entities = tbWtBillDetJpaRepository.getBillDetailEntity(billPrintIds, orgid);
        final List<TbBillDet> beans = new ArrayList<>();

		Organisation org = new Organisation();
		org.setOrgid(orgid);
		for (final TbWtBillDetEntity tbWtBillDetEntity : entities) {

			if (Utility.isEnvPrefixAvailable(org, MainetConstants.ENV_SKDCL)) {

				final String taxName = CommonMasterUtility
						.getHierarchicalLookUp(tbWtBillDetEntity.getTaxCategory(), org).getLookUpDesc();
				Optional<TbBillDet> sameTaxCodeIsPresent = null;
				if (!beans.isEmpty()) {
					sameTaxCodeIsPresent = beans.stream().filter(tax -> CommonMasterUtility
							.getHierarchicalLookUp(tax.getTaxCategory(), org).getLookUpDesc().equals(taxName))
							.findAny();
				}

				if (sameTaxCodeIsPresent == null
						|| (sameTaxCodeIsPresent != null && !sameTaxCodeIsPresent.isPresent())) {

					setBeans(tbWtBillDetEntity, beans, org);

				} else {
					TbBillDet existingBill = sameTaxCodeIsPresent.get();
					existingBill.setBdPrvArramt(existingBill.getBdPrvArramt() + tbWtBillDetEntity.getBdPrvArramt());
					existingBill.setBdPrvBalArramt(
							existingBill.getBdPrvBalArramt() + tbWtBillDetEntity.getBdPrvBalArramt());
					existingBill.setBdCurTaxamt(existingBill.getBdCurTaxamt() + tbWtBillDetEntity.getBdCurTaxamt());
					existingBill
							.setBdCurTaxamt(existingBill.getBdCurBalTaxamt() + tbWtBillDetEntity.getBdCurBalTaxamt());
					existingBill
							.setBaseRate(tbWtBillDetEntity.getBaseRate() != null
									? (existingBill.getBaseRate() != null
											? existingBill.getBaseRate() + tbWtBillDetEntity.getBaseRate()
											: null)
									: existingBill.getBaseRate() != null ? existingBill.getBaseRate() : null);
				}

			} else {
				setBeans(tbWtBillDetEntity, beans, org);

			}

		}
		return beans;
	}

	private void setBeans(TbWtBillDetEntity tbWtBillDetEntity, List<TbBillDet> beans, Organisation org) {
		TbBillDet d = new TbBillDet();
		BeanUtils.copyProperties(tbWtBillDetEntity, d);

		final String taxCode = CommonMasterUtility.getHierarchicalLookUp(d.getTaxCategory(), org).getLookUpCode();

		// Defect No-33093. In case of interest arrears + current should be show under
		// current in bill printing.

		if (StringUtils.equals(taxCode, "P")) {
			d.setBdCurTaxamt(d.getBdPrvArramt() + d.getBdCurTaxamt());
			d.setBdPrvBalArramt(0.0);
			d.setBdPrvArramt(0.0);

		}
		d.setBmIdno(tbWtBillDetEntity.getBmIdNo().getBmIdno());
		beans.add(d);
	}

    private void setTaxCalculationDto(final TbTaxMas taxMas, final Long csIdn, final List<BillTaxDTO> taxAmountList,
            final Double tax, final String taxCategory1, String ruleId, double baseRate) {
        BillTaxDTO dto = new BillTaxDTO();
        dto.setTax(tax);
        dto.setTaxCategoryCodeValue(taxCategory1);
        dto.setTaxId(taxMas.getTaxId());
        dto.setTaxSequence(taxMas.getCollSeq());
        dto.setTaxCategory(taxMas.getTaxCategory1());
        dto.setTaxSubCategory(taxMas.getTaxCategory2());
        dto.setBaseRate(baseRate);
        dto.setRuleId(ruleId);
        taxAmountList.add(dto);
    }

    private Long setTaxSubCategoryForMeterAndNonMeter(final Organisation orgnisation, final String meterType) {
        Long taxSubCategoryId = null;
        final List<LookUp> taxSubCategory = CommonMasterUtility.getNextLevelData(PrefixConstants.LookUpPrefix.TAC,
                MainetConstants.INDEX.TWO, orgnisation.getOrgid());
        if (MainetConstants.NewWaterServiceConstants.METER.equals(meterType)) {
            for (final LookUp taxSubCat : taxSubCategory) {
                if (PrefixConstants.TAX_SUBCATEGORY.WATER_TAX_NONMETER.equals(taxSubCat.getLookUpCode())) {
                    taxSubCategoryId = taxSubCat.getLookUpId();
                }
            }
        } else {
            for (final LookUp taxSubCat : taxSubCategory) {
                if (PrefixConstants.TAX_SUBCATEGORY.WATER_TAX_METER.equals(taxSubCat.getLookUpCode())) {
                    taxSubCategoryId = taxSubCat.getLookUpId();
                }
            }
        }
        return taxSubCategoryId;
    }

    @Transactional
    @Override
    public List<Long> billCalculationAndGeneration(final Organisation orgnisation,
            final Map<Long, WaterBillGenErrorDTO> errorListMap, final List<TbCsmrInfoDTO> entitylist,
            final String remarks, final Long empId, final int langId, final List<Long> connectionIdList,
            String ipAddress, Long logLocId) {
        LOGGER.info(
                "/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ BillCalculationAndGeneration Started^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/");
        final List<Long> billNoList = new ArrayList<>();
        WSRequestDTO request = new WSRequestDTO();

        // Here Consumption and No of days both sheet are same , in case of Aqua it is
        // different
        request.setModelName("WaterRateMaster|WaterTaxCalculation|NoOfDays");

        // BRMS Call
        final WSResponseDTO response = RestClient.callBRMS(request,
                ServiceEndpoints.BRMSMappingURL.INITIALIZE_MODEL_URL);

        if (response != null && MainetConstants.Req_Status.SUCCESS.equals(response.getWsStatus())) {

            List<Object> waterRate = RestClient.castResponse(response, WaterRateMaster.class, 0);
            List<Object> waterTax = RestClient.castResponse(response, WaterTaxCalculation.class, 1);
            List<Object> noOfDays = RestClient.castResponse(response, NoOfDays.class, 2);

            WaterRateMaster rateMasterInit = (WaterRateMaster) waterRate.get(0);

            WaterTaxCalculation taxCalculationInit = (WaterTaxCalculation) waterTax.get(0);

            NoOfDays noOfDaysInit = (NoOfDays) noOfDays.get(0);
            final Map<Long, Boolean> billPresent = new HashMap<>(0);
            final Map<Long, BillTaxDTO> meterReadingMap = new HashMap<>(0);
            final Map<Long, Long> gapDays = new HashMap<>(0);
            Long finYearId = entitylist.size() == 1 && entitylist.get(0).getPcDate()!=null ? 
            		iFinancialYearService.getFinanceYearId(entitylist.get(0).getPcDate())
                		: iFinancialYearService.getFinanceYearId(new Date());

            final Map<Long, SMSAndEmailDTO> smsEmailMap = new HashMap<>(0);

            Long taxSubCategoryIdMeter = setTaxSubCategoryForMeterAndNonMeter(orgnisation,
                    MainetConstants.NewWaterServiceConstants.METER);
            Long taxSubCategoryIdNonMeter = setTaxSubCategoryForMeterAndNonMeter(orgnisation,
                    MainetConstants.NewWaterServiceConstants.NON_METER);

            final Long deptId = departmentService.getDepartmentIdByDeptCode(MainetConstants.WATER_DEPT,
                    MainetConstants.STATUS.ACTIVE);

            final LookUp chargeApplicableAt = CommonMasterUtility.getValueFromPrefixLookUp(
                    PrefixConstants.NewWaterServiceConstants.BILL, PrefixConstants.NewWaterServiceConstants.CAA,
                    orgnisation);
            
            final LookUp chargeApplicableAtBillReceipt = CommonMasterUtility.getValueFromPrefixLookUp(
            		PrefixConstants.NewWaterServiceConstants.BILL_RECEIPT, PrefixConstants.NewWaterServiceConstants.CAA,
                    orgnisation);
            
            final List<TbTaxMas> taxListMeter = new ArrayList<>(0);

            // order is important always indepndent tax should get calculated first
            // Parent Tax not dependent on any other tax
            taxListMeter.addAll(tbTaxMasService.fetchAllIndependentTaxes(orgnisation.getOrgid(), deptId,
                    chargeApplicableAt.getLookUpId(), taxSubCategoryIdMeter,chargeApplicableAtBillReceipt.getLookUpId()));

            // dependent tax depend on parent tax
            taxListMeter.addAll(tbTaxMasService.fetchAllDepenentTaxes(orgnisation.getOrgid(), deptId,
                    chargeApplicableAt.getLookUpId(), taxSubCategoryIdMeter,chargeApplicableAtBillReceipt.getLookUpId()));

            final List<TbTaxMas> taxListNonMeter = new ArrayList<>(0);

            taxListNonMeter.addAll(tbTaxMasService.fetchAllIndependentTaxes(orgnisation.getOrgid(), deptId,
                    chargeApplicableAt.getLookUpId(), taxSubCategoryIdNonMeter,chargeApplicableAtBillReceipt.getLookUpId()));

            taxListNonMeter.addAll(tbTaxMasService.fetchAllDepenentTaxes(orgnisation.getOrgid(), deptId,
                    chargeApplicableAt.getLookUpId(), taxSubCategoryIdNonMeter,chargeApplicableAtBillReceipt.getLookUpId()));

            // Fetch Un paid Bill
            Map<Long, List<TbBillMas>> notPaidBills = billMasterService.fetchAllUnpaidBillsForBilling(connectionIdList,
                    orgnisation.getOrgid());

            // Excess amount
            final Map<Long, TbWtExcessAmt> excessAmountData = fetchBalanceAdvancePaymentData(connectionIdList,
                    orgnisation.getOrgid());

            // In case ULB sent ULB notice that charge needs to be added in Bill
    		LOGGER.info(" After fetchBalanceAdvancePaymentData() method is executed");
            final Map<Long, DemandNotice> demandNotice = getDemandNoticeData(connectionIdList, orgnisation.getOrgid());

            final List<String> uniqueIds = connectionIdList.stream().map(Object::toString).collect(Collectors.toList());
            
            // Fetching all bill schedule list againt orgid
            Map<Long, List<TbWtBillSchedule>> nonMeterBllScheduleByOrgid = null;
            Map<Long, List<TbWtBillSchedule>> meterBllScheduleByOrgid = null;
            Map<Long, FinancialYear> finYearMap = new HashMap<Long, FinancialYear>();
            
            final LookUp meterType = CommonMasterUtility
                    .getNonHierarchicalLookUpObject(entitylist.get(0).getCsMeteredccn(), orgnisation);
            if(StringUtils.equals(meterType.getLookUpCode(), MainetConstants.NewWaterServiceConstants.NON_METER)) {
            	  nonMeterBllScheduleByOrgid = getNonMeterBllScheduleByOrgid(orgnisation);
            	  List<Long> finYearIdList = new ArrayList<Long>(nonMeterBllScheduleByOrgid.keySet());
            	  finYearMap = getFinYearList(finYearIdList);
            }else if(StringUtils.equals(meterType.getLookUpCode(), MainetConstants.NewWaterServiceConstants.METER)) {
            	meterBllScheduleByOrgid = getMeterBllScheduleByOrgid(orgnisation);
            	 List<Long> finYearIdList = new ArrayList<Long>(meterBllScheduleByOrgid.keySet());
            	 finYearMap = getFinYearList(finYearIdList);
            }
            final List<TbTaxMas> taxesMasterForReceipt = tbTaxMasService.findAllTaxesForBillPayment(orgnisation.getOrgid(), deptId,
                    chargeApplicableAt.getLookUpId());
            
            final List<TbTaxMas> taxesMasterBillReceipt = tbTaxMasService.findAllTaxesForBillPayment(orgnisation.getOrgid(), deptId,
            		chargeApplicableAtBillReceipt.getLookUpId());
            taxesMasterForReceipt.addAll(taxesMasterBillReceipt);
            
			LookUp taxCategoryLookUp = CommonMasterUtility.getHieLookupByLookupCode("P",
					PrefixConstants.LookUpPrefix.TAC, 1, orgnisation.getOrgid());
			LookUp taxSubCategoryLookUp = CommonMasterUtility.getHieLookupByLookupCode("SC",
					PrefixConstants.LookUpPrefix.TAC, 2, orgnisation.getOrgid());
			Long surchargeTaxId = tbTaxMasService.getTaxId(chargeApplicableAt.getLookUpId(), orgnisation.getOrgid(),
					deptId, taxCategoryLookUp.getLookUpId(), taxSubCategoryLookUp.getLookUpId());

            // if any adjustment is there as part of bill dispute it has to be consider in
            // next bill
            final Map<Long, List<AdjustmentMasterEntity>> adjustmentEntry = adjustmentService
                    .fetchAllAdjustmentEntry(uniqueIds, orgnisation.getOrgid(), deptId);

            if (connectionIdList != null && !connectionIdList.isEmpty()) {

            	if(Utility.isEnvPrefixAvailable(orgnisation, MainetConstants.ENV_SKDCL)) {
            		if(StringUtils.equals(meterType.getLookUpCode(), MainetConstants.NewWaterServiceConstants.METER)) {
            			if(CommonMasterUtility.getDefaultValue(MainetConstants.NewWaterServiceConstants.CUS_METER_BILL)
            					.getLookUpCode().equals(PrefixConstants.NewWaterServiceConstants.CUSTOM)) {
                		
                			meterReadingMap.putAll(tbMrdataService.getUnbilledMeterReading(connectionIdList,  orgnisation.getOrgid()));
                			
                		}else {
                			meterReadingMap.putAll(tbMrdataService.getMeterReadingData(connectionIdList, orgnisation.getOrgid()));
                		}
            		}
            		
                	// Commenting code as per Akshata Bhat for handling NPE D#140622
            		//checking physical connection and latest unbilled metered reading same or not for single connection
					/*
					 * if(meterReadingMap!=null && !meterReadingMap.isEmpty() &&
					 * meterReadingMap.get(connectionIdList.get(0))!=null) { BillTaxDTO billTaxDTO =
					 * meterReadingMap.get(connectionIdList.get(0));
					 * if(billTaxDTO.getMrdFrom().compareTo(billTaxDTO.getMrdTo())==0) { //bill
					 * cannot be generated throw new
					 * FrameworkException("Exception in calculating bill: Physical date of connection and bill generation for"
					 * + " connection number -> "+entitylist.get(0).getCsCcn()); } } else
					 * if(StringUtils.equals(meterType.getLookUpCode(),
					 * MainetConstants.NewWaterServiceConstants.NON_METER) && (
					 * entitylist.get(0).getPcDate().compareTo(new Date()) == 0 )) { //bill cannot
					 * be generated throw new
					 * FrameworkException("Exception in calculating bill: Physical date of connection and bill generation for"
					 * + " connection number -> "+entitylist.get(0).getCsCcn());
					 * 
					 * }
					 */
            	}else {
                    meterReadingMap.putAll(tbMrdataService.getMeterReadingData(connectionIdList, orgnisation.getOrgid()));
            	}
            	
            	
                // get bill schedule for which bills are not generated
				/*
				 * billSchedule.addAll(tbWtBillScheduleService.getBillScheduleByFinYearId(
				 * finYearId, orgnisation.getOrgid(),
				 * MainetConstants.NewWaterServiceConstants.NON_METER));
				 */

                billPresent.putAll(billMasterService.checkBillsForNonMeter(connectionIdList, orgnisation.getOrgid()));

                gapDays.putAll(waterExceptionalGapService.fetchForExceptionGap(connectionIdList, orgnisation.getOrgid(),
                        MainetConstants.RnLCommon.Y_FLAG));
            }
			/*
			 * final String billFrequency = CommonMasterUtility
			 * .getNonHierarchicalLookUpObject(billSchedule.get(0).getCnsCpdid(),
			 * orgnisation).getLookUpCode();
			 */
            
            final String billingMethodDesc = billingMethod(orgnisation);

            Set<Long> connectionids = new HashSet<>();
            // Long count = entitylist.parallelStream()
            // .filter(waterDTO -> MainetConstants.NewWaterServiceConstants.YES.equals(waterDTO.getPcFlg()))
            // .count();
            // every connection bill generation will
            // Lambda loop replaced with forEach due to unable to create session inside
			
            WaterBillGenerationMap flowDto = new WaterBillGenerationMap();
            
            List<Long> billIdListForVoucherPosting = new ArrayList<Long>();
            final Map<Long, List<TbWtBillSchedule>> nonMeterBllScheduleByOrgidFinal= nonMeterBllScheduleByOrgid;
            final Map<Long, List<TbWtBillSchedule>> meterBllScheduleByOrgidFinal =  meterBllScheduleByOrgid;
            final Map<Long, FinancialYear> finYearMapFinal = finYearMap;
            int count = entitylist.size();
            AtomicLong selectedCount = new AtomicLong(count);
            LOGGER.info("Water Bill Generation process is started total size is : "+count);
            final ExecutorService executorService = Executors.newFixedThreadPool(Integer.valueOf(ApplicationSession.getInstance().getMessage("bill.thread.pool.size")));
            //entitylist.parallelStream()
                    // .filter(waterDTO -> MainetConstants.NewWaterServiceConstants.YES.equals(waterDTO.getPcFlg()))
                   // .forEachOrdered(waterDTO -> {
			/* for (TbCsmrInfoDTO waterDTO : entitylist) { */

			entitylist.stream().forEach(waterDTO -> {
				executorService.execute(new Runnable() {
					// D#140622
					public void run() {
						LOGGER.info(String.format("starting expensive before task thread %s",
								Thread.currentThread().getName()));
						if (Utility.isEnvPrefixAvailable(orgnisation, MainetConstants.ENV_SKDCL) && StringUtils
								.equals(meterType.getLookUpCode(), MainetConstants.NewWaterServiceConstants.METER)) {
							customMeteredBillGeneration(orgnisation, errorListMap, entitylist, remarks, empId, langId,
									ipAddress, billNoList, rateMasterInit, taxCalculationInit, noOfDaysInit,
									billPresent, meterReadingMap, gapDays, finYearId, smsEmailMap, deptId,
									chargeApplicableAt, taxListMeter, taxListNonMeter, notPaidBills, excessAmountData,
									demandNotice, nonMeterBllScheduleByOrgidFinal, meterBllScheduleByOrgidFinal,
									finYearMapFinal, meterType, taxesMasterForReceipt, surchargeTaxId, adjustmentEntry,
									billingMethodDesc, connectionids, flowDto, billIdListForVoucherPosting,
									selectedCount, waterDTO);
						} else {
							waterBillGeneration(orgnisation, errorListMap, entitylist, remarks, empId, langId,
									ipAddress, billNoList, rateMasterInit, taxCalculationInit, noOfDaysInit,
									billPresent, meterReadingMap, gapDays, finYearId, smsEmailMap, deptId,
									chargeApplicableAt, taxListMeter, taxListNonMeter, notPaidBills, excessAmountData,
									demandNotice, nonMeterBllScheduleByOrgidFinal, meterBllScheduleByOrgidFinal,
									finYearMapFinal, meterType, taxesMasterForReceipt, surchargeTaxId, adjustmentEntry,
									billingMethodDesc, connectionids, flowDto, billIdListForVoucherPosting,
									selectedCount, waterDTO);
						}
						LOGGER.info(String.format("starting expensive after task thread %s after",
								Thread.currentThread().getName()));
					}
				});

			});
			executorService.shutdown();
			while (!executorService.isTerminated()) {

			}
			LOGGER.info("\nFinished all threads");
			
			ApplicationContextProvider.getApplicationContext().getBean(BillMasterCommonService.class)
					.doVoucherPosting(billIdListForVoucherPosting, orgnisation, MainetConstants.DEPT_SHORT_NAME.WATER, empId, logLocId);
            
            if (!connectionids.isEmpty() && StringUtils.equals(meterType.getLookUpCode(), MainetConstants.NewWaterServiceConstants.METER)) {
                updateBillGeneratedFlagInMeter(connectionids, orgnisation.getOrgid());
            }
            insertIntoErrorTable(orgnisation, errorListMap, empId);
        }
		LOGGER.info("End--> " + this.getClass().getSimpleName() + " billCalculationAndGeneration() method ");
        return billNoList;

    }

	private void waterBillGeneration(final Organisation orgnisation, final Map<Long, WaterBillGenErrorDTO> errorListMap,
			final List<TbCsmrInfoDTO> entitylist, final String remarks, final Long empId, final int langId,
			String ipAddress, final List<Long> billNoList, WaterRateMaster rateMasterInit,
			WaterTaxCalculation taxCalculationInit, NoOfDays noOfDaysInit, final Map<Long, Boolean> billPresent,
			final Map<Long, BillTaxDTO> meterReadingMap, final Map<Long, Long> gapDays, Long finYearId,
			final Map<Long, SMSAndEmailDTO> smsEmailMap, final Long deptId, final LookUp chargeApplicableAt,
			final List<TbTaxMas> taxListMeter, final List<TbTaxMas> taxListNonMeter,
			Map<Long, List<TbBillMas>> notPaidBills, final Map<Long, TbWtExcessAmt> excessAmountData,
			final Map<Long, DemandNotice> demandNotice, Map<Long, List<TbWtBillSchedule>> nonMeterBllScheduleByOrgid,
			Map<Long, List<TbWtBillSchedule>> meterBllScheduleByOrgid, Map<Long, FinancialYear> finYearMap,
			final LookUp meterType, final List<TbTaxMas> taxesMasterForReceipt, Long surchargeTaxId,
			final Map<Long, List<AdjustmentMasterEntity>> adjustmentEntry, final String billingMethodDesc,
			Set<Long> connectionids, WaterBillGenerationMap flowDto, List<Long> billIdListForVoucherPosting,
			AtomicLong selectedCount, TbCsmrInfoDTO waterDTO) {
		LOGGER.info("Begin--> " + this.getClass().getSimpleName() + " waterBillGeneration() method & Connection No. : "+waterDTO.getCsCcn());

		long startTime = System.currentTimeMillis();
		List<TbBillMas> currentnotPaidBills = new ArrayList<>();
		// for (TbCsmrInfoDTO waterDTO : entitylist) {
		// if (MainetConstants.NewWaterServiceConstants.YES.equals(waterDTO.getPcFlg()))
		// {
		LOGGER.info("Bill Generation started for Connection" + waterDTO.getCsCcn());
		
		LOGGER.info("Bill Generation started for Connection Count" + selectedCount);
		List<TbWtBillMasEntity> newbillsGenerated = new ArrayList<>(0);
		final WaterBillGenErrorDTO errorDto = new WaterBillGenErrorDTO();
		try {
		    // final List<BillTaxDTO> taxAmountList = new ArrayList<>(0);

		    Map<Long, WaterRateMaster> waterRateMap = new LinkedHashMap<>(0);

		    Map<Long, WaterTaxCalculation> taxCalculationMap = new LinkedHashMap<>(0);
		    

		    TbWtExcessAmt excessAmount = null;
		    DemandNotice demandNoticeCharge = null;
		    AtomicDouble interestValue = new AtomicDouble(0);
		    BillTaxDTO interestTaxDto = null;
		    Long interestTaxId = 0l;
		    List<TbTaxMas> taxList = taxListMeter;
		    TbWtBillMasEntity billmas = null;
		    List<TbWtBillMasEntity> billList = tbWtBillMasJpaRepository
		            .getBillMasByConnectionId(waterDTO.getCsIdn());

		    List<TbWtBillMasEntity> billGenerated = new ArrayList<>(0);
			int cycleLength = 0;
	        List<TbWtBillMasEntity> calculatedBills = null;

		    // preserving the current detail bill schedule
		    
		    /*
		     * this will check if previous bills are generated or not if yes then execute if clause otherwise else
		     * clause check whether bills are present if present then check the difference between last bill to
		     * date and current date
		     */
		  
		   // List<Long> finYearListFromLastBillGenDate = getFinYearListFromLastBillGenDate(billList, billmas,finYearId);
		    
		    List<Long> finYearListFromLastBillGenDate = CollectionUtils.isEmpty(billList) ? 
		    		getFinYearListFromLastBillGenDateOrPcDate(orgnisation.getOrgid(), finYearId) : 
		    			 getFinYearListFromLastBillGenDate(billList, billmas,finYearId);
		    		
		    		
		    // Loop To generate Bill for the no. of months and financial years for which bills are not generated
		    // till date
		    // Added one more loop for financial year wise pending bills. Defect No: 39322 by srikanth
		    for (Long finYear : finYearListFromLastBillGenDate) {
		    	List<TbWtBillSchedule> billScheduleByFinYearId = null;
		    	if(StringUtils.equals(meterType.getLookUpCode(), MainetConstants.NewWaterServiceConstants.NON_METER) && MapUtils.isNotEmpty(nonMeterBllScheduleByOrgid)) {
		    		billScheduleByFinYearId = new ArrayList<TbWtBillSchedule>();
		    		billScheduleByFinYearId = nonMeterBllScheduleByOrgid.get(finYear);
		    	}else if(StringUtils.equals(meterType.getLookUpCode(), MainetConstants.NewWaterServiceConstants.METER) && MapUtils.isNotEmpty(meterBllScheduleByOrgid)) {
		    		billScheduleByFinYearId = new ArrayList<TbWtBillSchedule>();
		    		billScheduleByFinYearId = meterBllScheduleByOrgid.get(finYear);
		    	}
		    	if(CollectionUtils.isNotEmpty(billScheduleByFinYearId)) {
		    		final List<TbWtBillSchedule> billSchedule = new ArrayList<>(0);
		    	  billSchedule.addAll(billScheduleByFinYearId);
		    	  List<TbWtBillScheduleDetail> tbWtBillScheduleDetail = billScheduleByFinYearId.get(0)
		                  .getBillScheduleDetail();
		    	  final String yearWiseBillFrequency = CommonMasterUtility
		                  .getNonHierarchicalLookUpObject(billScheduleByFinYearId.get(0).getCnsCpdid(), orgnisation).getLookUpCode();
		    	 // FinancialYear finincialYearDto = iFinancialYearService.getFinincialYearsById(finYear, orgnisation.getOrgid());
		    	  FinancialYear finincialYearDto = finYearMap.get(finYear);
		    	  List<Integer> monthCalculations = findNoOfMonthBillGenerated(billList, billmas,
		    			  yearWiseBillFrequency, meterType.getLookUpCode(),finincialYearDto, orgnisation);
		    	  LOGGER.info("no od months: "+monthCalculations);
		    	  TbWtBillSchedule createCopyOfBillSchedule = createCopyOfBillSchedule(billScheduleByFinYearId.get(0));
		    	  LOGGER.info("Before execution of monthCalculations loop");	
		    	  
		    for (int monthCount = 0; monthCount < monthCalculations.get(0); monthCount++) {
		    	LOGGER.info("inside for 1106 ");
		        List<BillTaxDTO> taxAmountList1 = new ArrayList<>(0);
		        // this is for Non Meter
		        TbWtBillSchedule schedule = createCopyOfBillSchedule;
		        schedule.setBillScheduleDetail(new ArrayList<>());
		        // providing the corresponding Bill schedule detail only for no. of Days purpose
		        LOGGER.info("inside for 1107 ");
		        schedule.getBillScheduleDetail()
		                .add(tbWtBillScheduleDetail.get(monthCount + monthCalculations.get(1)));
		        LOGGER.info("inside for 1108 ");
		        List<TbWtBillSchedule> currentBillSchedule = new ArrayList<>();
		        currentBillSchedule.add(schedule);
		       // if(Utility.compareDate(currentBillSchedule.get(0).getCnsMfcpdval(), new Date()))
		        if (MainetConstants.NewWaterServiceConstants.NON_METER
		                .equals(meterType.getLookUpCode())) {
		            // to avoid initiatalized call
		        	LOGGER.info("inside for 1109 ");
		            NoOfDays noOfDaysCalculation = (NoOfDays) noOfDaysInit.clone();
		            // This will call BRMS and populated no of days model
		            LOGGER.info("inside for 1110 ");
		            meterReadingMap.put(waterDTO.getCsIdn(),
		                    populateNonMeterDataForNoOfDays(waterDTO, orgnisation, currentBillSchedule,
		                            billPresent.get(waterDTO.getCsIdn()),
		                            gapDays.get(waterDTO.getCsIdn()), meterType.getDescLangFirst(),
		                            billingMethodDesc, noOfDaysCalculation,
		                            CollectionUtils.isEmpty(billList) ? null
		                                    : billList.get(billList.size() - 1),finincialYearDto));
		            taxList = taxListNonMeter;
		            if(Utility.isEnvPrefixAvailable(orgnisation, MainetConstants.ENV_SKDCL)) {
		            	LOGGER.info("skdcl inside for 1111 ");
		            	cycleLength = cycleLength != 0 ? cycleLength
								: CollectionUtils.isEmpty(billList) ? 6
										: monthsBetweenDates(billList.get(billList.size() - 1).getBmFromdt(),
												billList.get(billList.size() - 1).getBmTodt()) + 1;
		            }
							
		        }

		        // if rule is not set or meter data will not be available
		        BillTaxDTO meter = meterReadingMap.get(waterDTO.getCsIdn());
		        if (MainetConstants.NewWaterServiceConstants.METER.equals(meterType.getLookUpCode())) {
		        	currentBillSchedule.get(0).getBillScheduleDetail().get(0).setYearId(finYear);
		            List<Date> meterCycleDate = getCycleStartandEndForMeterConnection(
		                    currentBillSchedule.get(0).getBillScheduleDetail().get(0));
		            meter.setMrdFrom(meterCycleDate.get(0));
		            meter.setMrdTo(meterCycleDate.get(1));
		            
		        }
		        Map<Long, TbTaxMas> taxes = new HashMap<>(0);

		        if (meter != null) {
//		        	calculatedBills = calculateTaxesAndGenerateBill(taxList, waterDTO, orgnisation, rateMasterInit, meter, errorDto, errorListMap,
//		        			meterType, billingMethodDesc, chargeApplicableAt, billSchedule, waterRateMap, taxCalculationInit,
//			        		taxCalculationMap, interestTaxId, interestTaxDto, excessAmount, excessAmountData, demandNotice,
//			        		demandNoticeCharge, taxAmountList1, finYearListFromLastBillGenDate, billGenerated, currentnotPaidBills,
//			        		taxes, langId, interestValue, smsEmailMap, notPaidBills, monthCount, finYear, connectionids,
//			        		adjustmentEntry, cycleLength, remarks, ipAddress, empId);
//		        	 
				 	LOGGER.info("calculateTaxesAndGenerateBill");
			    	try {
			    		// for each connection tax wise loop is going
			            for (final TbTaxMas taxMas : taxList) {
			            	//#135897 changes for interest calculation for ASCL Project
			            	final LookUp lookUp = CommonMasterUtility.getNonHierarchicalLookUpObject(waterDTO.getCsCcnsize(), orgnisation);
			            	String ccnTyp = lookUp.getLookUpCode().equals(PrefixConstants.NewWaterServiceConstants.SWR) ? PrefixConstants.NewWaterServiceConstants.CCN_TYP_SEWER : 
			                	NewWaterServiceConstants.CCN_TYP_WTR ;
			            	if (Utility.isEnvPrefixAvailable(orgnisation, MainetConstants.ENV_ASCL)) {
			            	if (taxMas.getTaxDesc().toUpperCase().contains(ccnTyp)) {
			            	
			                LookUp taxType = CommonMasterUtility.getNonHierarchicalLookUpObject(
			                        Long.valueOf(taxMas.getTaxMethod()), orgnisation);
			                LookUp taxCategory1 = CommonMasterUtility
			                        .getHierarchicalLookUp(taxMas.getTaxCategory1(), orgnisation);

			    			if (!PrefixConstants.TAX_CATEGORY.ADVANCE.equals(taxCategory1.getLookUpCode())
			    					&& !PrefixConstants.TAX_CATEGORY.NOTICE
			    							.equals(taxCategory1.getLookUpCode()) && !PrefixConstants.TAX_CATEGORY.PENALTY
			    							.equals(taxCategory1.getLookUpCode())) {

			                    WaterRateMaster rateMaster = (WaterRateMaster) rateMasterInit.clone();
			                    WaterTaxCalculation taxCalculation = (WaterTaxCalculation) taxCalculationInit.clone();
			                    setMeterNonMeterData(waterDTO, meter, errorDto, errorListMap, orgnisation,
			                            rateMaster, taxCalculation, meterType, billingMethodDesc);
			                    rateMaster.setChargeApplicableAt(chargeApplicableAt.getDescLangFirst());
			                    waterRateMap.put(taxMas.getTaxId(),
			                            populateRateMasterModel(waterDTO, taxMas, taxCategory1, taxType,
			                            		orgnisation, rateMaster, billSchedule));

			                    if (PrefixConstants.TAX_CATEGORY.INTERST
			                            .equals(taxCategory1.getLookUpCode())) {
			                        interestTaxDto = new BillTaxDTO();
			                        interestTaxDto.setTaxCategoryCodeValue(taxCategory1.getLookUpCode());
			                        interestTaxDto.setTaxId(taxMas.getTaxId());
			                        interestTaxDto.setTaxSequence(taxMas.getCollSeq());
			                        interestTaxDto.setTaxCategory(taxMas.getTaxCategory1());
			                        interestTaxDto.setTaxSubCategory(taxMas.getTaxCategory2());
			                        interestTaxId = taxMas.getTaxId();
			                    }
			                    // Telescopic case calculation is in JAVA for other case it in Rule
			                    // Sheet-Tax Calculation
			                    else if (!PrefixConstants.TAX_TYPE.TELESCOPIC
			                            .equals(taxType.getLookUpCode())) {
			                        taxCalculation.setTaxCategory(taxCategory1.getLookUpCode());

			                        // calculation in map
			                        taxCalculationMap.put(taxMas.getTaxId(), populateTaxCalculationModel(
			                                waterDTO, taxMas, taxType, orgnisation, taxCalculation));
			                    }
			                }
			                // only setting calculated amount
			                else if (PrefixConstants.TAX_CATEGORY.ADVANCE
			                        .equals(taxCategory1.getLookUpCode())) {
			                    excessAmount = excessAmountData.get(waterDTO.getCsIdn());
			                    if (excessAmount != null) {
			                        // just setting the dto
			                        setTaxCalculationDto(taxMas, waterDTO.getCsIdn(), taxAmountList1,
			                                excessAmount.getExcAmt(), taxCategory1.getLookUpCode(), null,
			                                0d);
			                    }
			                }
			                // only setting calcualted amount
			                else if (PrefixConstants.TAX_CATEGORY.NOTICE
			                        .equals(taxCategory1.getLookUpCode())) {
			                    demandNoticeCharge = demandNotice.get(waterDTO.getCsIdn());
			                    if ((demandNoticeCharge != null)
			                            && demandNoticeCharge.getTaxCode().equals(taxMas.getTaxCode())) {
			                        demandNoticeCharge.setIsDeleted(MainetConstants.YES);
			                        setTaxCalculationDto(taxMas, waterDTO.getCsIdn(), taxAmountList1,
			                                demandNoticeCharge.getTaxAmount(), taxCategory1.getLookUpCode(),
			                                null, 0d);
			                    }
			                }
			                taxes.put(taxMas.getTaxId(), taxMas);
			            	}
			            }else {
			            LookUp taxType = CommonMasterUtility.getNonHierarchicalLookUpObject(
			                        Long.valueOf(taxMas.getTaxMethod()), orgnisation);
			                LookUp taxCategory1 = CommonMasterUtility
			                        .getHierarchicalLookUp(taxMas.getTaxCategory1(), orgnisation);

			    			if (!PrefixConstants.TAX_CATEGORY.ADVANCE.equals(taxCategory1.getLookUpCode())
			    					&& !PrefixConstants.TAX_CATEGORY.NOTICE
			    							.equals(taxCategory1.getLookUpCode()) && !PrefixConstants.TAX_CATEGORY.PENALTY
			    							.equals(taxCategory1.getLookUpCode())) {

			                    WaterRateMaster rateMaster = (WaterRateMaster) rateMasterInit.clone();
			                    WaterTaxCalculation taxCalculation = (WaterTaxCalculation) taxCalculationInit
			                            .clone();
			                    setMeterNonMeterData(waterDTO, meter, errorDto, errorListMap, orgnisation,
			                            rateMaster, taxCalculation, meterType, billingMethodDesc);
			                    rateMaster.setChargeApplicableAt(chargeApplicableAt.getDescLangFirst());
			                    waterRateMap.put(taxMas.getTaxId(),
			                            populateRateMasterModel(waterDTO, taxMas, taxCategory1, taxType,
			                                    orgnisation, rateMaster, billSchedule));

			                    if (PrefixConstants.TAX_CATEGORY.INTERST
			                            .equals(taxCategory1.getLookUpCode())) {
			                        interestTaxDto = new BillTaxDTO();
			                        interestTaxDto.setTaxCategoryCodeValue(taxCategory1.getLookUpCode());
			                        interestTaxDto.setTaxId(taxMas.getTaxId());
			                        interestTaxDto.setTaxSequence(taxMas.getCollSeq());
			                        interestTaxDto.setTaxCategory(taxMas.getTaxCategory1());
			                        interestTaxDto.setTaxSubCategory(taxMas.getTaxCategory2());
			                        interestTaxId = taxMas.getTaxId();
			                    }
			                    // Telescopic case calculation is in JAVA for other case it in Rule
			                    // Sheet-Tax Calculation
			                    else if (!PrefixConstants.TAX_TYPE.TELESCOPIC
			                            .equals(taxType.getLookUpCode())) {
			                        taxCalculation.setTaxCategory(taxCategory1.getLookUpCode());

			                        // calculation in map
			                        taxCalculationMap.put(taxMas.getTaxId(), populateTaxCalculationModel(
			                                waterDTO, taxMas, taxType, orgnisation, taxCalculation));
			                    }
			                }
			                // only setting calculated amount
			                else if (PrefixConstants.TAX_CATEGORY.ADVANCE
			                        .equals(taxCategory1.getLookUpCode())) {
			                    excessAmount = excessAmountData.get(waterDTO.getCsIdn());
			                    if (excessAmount != null) {
			                        // just setting the dto
			                        setTaxCalculationDto(taxMas, waterDTO.getCsIdn(), taxAmountList1,
			                                excessAmount.getExcAmt(), taxCategory1.getLookUpCode(), null,
			                                0d);
			                    }
			                }
			                // only setting calcualted amount
			                else if (PrefixConstants.TAX_CATEGORY.NOTICE
			                        .equals(taxCategory1.getLookUpCode())) {
			                    demandNoticeCharge = demandNotice.get(waterDTO.getCsIdn());
			                    if ((demandNoticeCharge != null)
			                            && demandNoticeCharge.getTaxCode().equals(taxMas.getTaxCode())) {
			                        demandNoticeCharge.setIsDeleted(MainetConstants.YES);
			                        setTaxCalculationDto(taxMas, waterDTO.getCsIdn(), taxAmountList1,
			                                demandNoticeCharge.getTaxAmount(), taxCategory1.getLookUpCode(),
			                                null, 0d);
			                    }
			                }
			                taxes.put(taxMas.getTaxId(), taxMas);		            	
			             }
			            }
			            final Long interestTax = interestTaxId;
			            // all calculation MAP is created and send to BRMS call to avoid multiple
			            // call
			            rateMasterAndTaxCalculationBRMS(orgnisation, waterDTO, taxAmountList1, waterRateMap,
			    						taxCalculationMap, interestValue, taxes, interestTax, cycleLength);

			    				if (taxAmountList1 != null && !taxAmountList1.isEmpty()) {
			    					
			    					final Date dueDate = Utility.isEnvPrefixAvailable(orgnisation, MainetConstants.ENV_SKDCL)?
			    							new Date(new Date().getTime() + STD_DUE_DATE) : 
			    							getBillDueDate(orgnisation, meterType.getLookUpCode(), meter);
			    					/*
			    					 * In First Iteration(For monthCount == 0) it will take unpaid bills from
			    					 * Fetched unpaid bills and for next iteration if exist it will take the not
			    					 * paid bills from the bills currently generated as that are not exist in
			    					 * previously fetched not paid bills
			    					 */

			    					if (Utility.isEnvPrefixAvailable(orgnisation, MainetConstants.ENV_PSCL)) {
			    						// to calculate actual arrears amount we need reference of unpaid bills
			    						if (MainetConstants.NewWaterServiceConstants.NON_METER
		        								.equals(meterType.getLookUpCode())) {
		        							if (finYearListFromLastBillGenDate.get(0).equals(finYear)) {

		        								if(monthCount == 0 && !notPaidBills.isEmpty()) {
		        									currentnotPaidBills.addAll(notPaidBills.get(waterDTO.getCsIdn()));
		        									notPaidBills.clear();
		        								}
		        							} else if (CollectionUtils.isEmpty(currentnotPaidBills) && CollectionUtils.isNotEmpty(billGenerated)) {
		        								currentnotPaidBills.addAll(getUnpaidBillEntityToDto(billGenerated));
		        							}
		        						} else {
		        							if(notPaidBills.get(waterDTO.getCsIdn())!=null) {
		            							currentnotPaidBills.addAll(notPaidBills.get(waterDTO.getCsIdn()));
		        							}
		        						}
			    						
			    					} else {
			    						if (finYearListFromLastBillGenDate.get(0).equals(finYear)) {
			    							currentnotPaidBills = monthCount == 0 ? notPaidBills.get(waterDTO.getCsIdn())
			    									: getUnpaidBillEntityToDto(billGenerated);
			    						}
			    					}

			                // Now call Bill Generation
			    			billGenerated = billMasterService.billGeneartion(taxAmountList1, meter,
			                		waterDTO, interestValue.doubleValue(), remarks, orgnisation, langId,
			                        empId, excessAmount, interestTaxDto, dueDate, currentnotPaidBills,
			                        adjustmentEntry.get(waterDTO.getCsIdn()), finYear, ipAddress);
			                		connectionids.add(waterDTO.getCsIdn());
			                
			                smsEmailMap.put(waterDTO.getCsIdn(), setSmsEmailDto(waterDTO,
			                        billGenerated.get(billGenerated.size() - 1), empId));
			            } else {

			                // error message tax not calculated , rule not found

			                LOGGER.error("error message tax not calculated , rule not found");
			                final String errorMsg = ApplicationSession.getInstance()
			                        .getMessage("error message tax not calculated , rule not found");
			                setErrorMap(errorListMap, errorDto, waterDTO, errorMsg);

			            }
			    	}catch(Exception e) {
			    		LOGGER.error("Error in water tax calculation and bill generation of connection number ", waterDTO.getCsCcn() + " " + e.getMessage());
			  		    final String errorMsg = ApplicationSession.getInstance().getMessage("water.bill.error");
			  		    setErrorMap(errorListMap, errorDto, waterDTO, errorMsg);
			  		
					}

				

		        } else {
		        	LOGGER.info("Meter is null");
		            final String errorMsg = ApplicationSession.getInstance()
		                    .getMessage("water.bill.nonMeterDays");
		            setErrorMap(errorListMap, errorDto, waterDTO, errorMsg);
		        }
		        
		    }
		    }
		   
		    // }
		    	
		    }  
		    newbillsGenerated.addAll(billGenerated);
		    }
		
		// for each schedule for loop
		catch (Exception e) {
		    LOGGER.error("Error in water bill generation of connection number "+ waterDTO.getCsCcn() +" of method waterBillGeneration : \n" +e.getMessage());
		    final String errorMsg = ApplicationSession.getInstance().getMessage("water.bill.error");
		    setErrorMap(errorListMap, errorDto, waterDTO, errorMsg);
		}
		
		 calculatePenaltiesIncurredOnPrevBills(newbillsGenerated, currentnotPaidBills, taxListNonMeter, orgnisation,
				selectedCount, errorListMap, waterDTO, entitylist, flowDto, smsEmailMap, langId, empId, ipAddress, billNoList,
				billIdListForVoucherPosting, finYearId, deptId, startTime, adjustmentEntry);
		
	
	}

    private SMSAndEmailDTO setSmsEmailDto(TbCsmrInfoDTO waterDTO, TbWtBillMasEntity billEntity, Long empId) {
        final SMSAndEmailDTO dto = new SMSAndEmailDTO();
        dto.setUserName(waterDTO.getCsName());
        dto.setEmail(waterDTO.getCsEmail());
        dto.setMobnumber(waterDTO.getCsContactno());
        dto.setConNo(waterDTO.getCsCcn());
        dto.setBillNo(billEntity.getBmNo());
        dto.setDueDt(Utility.dateToString(billEntity.getBmDuedate()));
        dto.setAmount(billEntity.getBmTotalOutstanding());
        dto.setUserId(empId);
        return dto;
    }

    private void sendMail(Organisation orgnisation, int langId, SMSAndEmailDTO smsAndEmailDTO) {
        if (smsAndEmailDTO != null) {
            ismsAndEmailService.sendEmailSMS(MainetConstants.DEPT_SHORT_NAME.WATER, "WaterBillGeneration.html",
                    PrefixConstants.SMS_EMAIL_ALERT_TYPE.SUBMITTED, smsAndEmailDTO, orgnisation, langId);
        }
    }

	private void rateMasterAndTaxCalculationBRMS(final Organisation orgnisation, final TbCsmrInfoDTO waterDTO,
			final List<BillTaxDTO> taxAmountList, Map<Long, WaterRateMaster> waterRateMap,
			Map<Long, WaterTaxCalculation> taxCalculationMap, AtomicDouble interestValue, Map<Long, TbTaxMas> taxes,
			final Long interestTax, int cycleLength) {
		LOGGER.info(
				"/*---------------------------- Print Connection Details------------------------------------------*/"
						+ waterDTO.toString());

		Map<Long, WaterRateMaster> waterRates = calculateRateMasterBRMS(waterRateMap);
		waterRates.forEach((taxId, rates) -> {
			if (Utility.isEnvPrefixAvailable(orgnisation, MainetConstants.ENV_SKDCL)) {
				rates.setFlatRate(cycleLength!= 0? rates.getFlatRate() * cycleLength
						* (waterDTO.getNoOfFamilies() != null ? waterDTO.getNoOfFamilies() : 1) : rates.getFlatRate());
			}

			TbTaxMas taxMas = taxes.get(taxId);
			LookUp taxType = CommonMasterUtility.getNonHierarchicalLookUpObject(Long.valueOf(taxMas.getTaxMethod()),
					orgnisation);
			LOGGER.info("/*----------------------------For the tax :" + taxMas.getTaxDesc() + ",Flat rate is :"
					+ rates.getFlatRate() + " ,percentage Rate is :" + rates.getPercentageRate() + " Slab are ("
					+ rates.getSlab1() + "," + rates.getSlab2() + "," + rates.getSlab3() + "," + rates.getSlab4()
					+ ") ,Slab rate are (" + rates.getSlabRate1() + "," + rates.getSlabRate2() + ","
					+ rates.getSlabRate3() + "," + rates.getSlabRate4() + ") ,and Rule id is :" + rates.getRuleId()
					+ "----------------------------------------*/");
			if (interestTax.equals(taxId)) {
				/*
				 * interestValue.addAndGet(WaterCommonUtility.getAndSetBaseRate(rates.
				 * getConsumption(), rates, null, taxType.getLookUpCode()));
				 */
				interestValue.set(WaterCommonUtility.getAndSetBaseRate(rates.getConsumption(), rates, null,
						taxType.getLookUpCode()));
			} else {
				if (taxType.getLookUpCode().equals(PrefixConstants.TAX_TYPE.TELESCOPIC)) {

                    // telescopeic calcluation is there
                    setTaxCalculationDto(taxMas, waterDTO.getCsIdn(), taxAmountList,
                            WaterCommonUtility.getAndSetBaseRate(rates.getConsumption(), rates, null,
                                    taxType.getLookUpCode()),
                            CommonMasterUtility.getHierarchicalLookUp(taxMas.getTaxCategory1(), orgnisation)
                                    .getLookUpCode(),
                            rates.getRuleId(), 0d);
                } else {

                    // other wise set the rate currently rule id is going it has to be rate code
                    WaterTaxCalculation waterTaxCalculation = taxCalculationMap.get(taxId);
                    WaterCommonUtility.getAndSetBaseRate(rates.getConsumption(), rates, waterTaxCalculation,
                            taxType.getLookUpCode());
                }
            }
        });

        // after Rate actual tax calculation happened
        Map<Long, WaterTaxCalculation> taxCalculation = calculateTaxCalBRMS(taxCalculationMap);
        taxCalculation.forEach((taxId, taxAmount) -> {
            TbTaxMas taxMas = taxes.get(taxId);
            if(taxAmount.getTax() > 0) {
            	setTaxCalculationDto(taxMas, waterDTO.getCsIdn(), taxAmountList, taxAmount.getTax(),
                        CommonMasterUtility.getHierarchicalLookUp(taxMas.getTaxCategory1(), orgnisation).getLookUpCode(),
                        taxAmount.getRuleId(), taxAmount.getBaseRate());
            }
        });
    }

    private String billingMethod(final Organisation orgnisation) {
        final List<LookUp> billingMethod = CommonMasterUtility.getListLookup(PrefixConstants.WATERMODULEPREFIX.WFB,
                orgnisation);
        String billingMethodDescVal = null;
        for (final LookUp lookUp : billingMethod) {
            if (lookUp.getDefaultVal().equals(PrefixConstants.IsLookUp.STATUS.YES)) {
                billingMethodDescVal = lookUp.getDescLangFirst();
                break;
            }
        }
        return billingMethodDescVal;
    }

    private Map<Long, WaterTaxCalculation> calculateTaxCalBRMS(Map<Long, WaterTaxCalculation> taxCalculationMap) {
        final WSRequestDTO request = new WSRequestDTO();
        request.setDataModel(taxCalculationMap);
        Map<Long, WaterTaxCalculation> taxCalculation = null;
        final WSResponseDTO result = RestClient.callBRMS(request, ServiceEndpoints.BRMSMappingURL.WATER_TAX_BILL_URL);
        if ((result != null) && MainetConstants.WebServiceStatus.SUCCESS.equalsIgnoreCase(result.getWsStatus())) {
            taxCalculation = castResponseToTaxCalculation(result);
        }
        return taxCalculation;
    }

    @SuppressWarnings("unchecked")
    private Map<Long, WaterTaxCalculation> castResponseToTaxCalculation(WSResponseDTO result) {
        Map<Long, WaterTaxCalculation> dataModel = null;
        LinkedHashMap<Long, Object> responseMap = (LinkedHashMap<Long, Object>) result.getResponseObj();
        String jsonString = new JSONObject(responseMap).toString();
        try {
            TypeReference<HashMap<Long, WaterTaxCalculation>> typeRef = new TypeReference<HashMap<Long, WaterTaxCalculation>>() {
            };
            dataModel = (Map<Long, WaterTaxCalculation>) new ObjectMapper().readValue(jsonString, typeRef);
        } catch (IOException e) {
            LOGGER.error("Error while casting model from WSRequestDTO water tax Calculation ", e);
        }
        return dataModel;
    }

    private Map<Long, WaterRateMaster> calculateRateMasterBRMS(Map<Long, WaterRateMaster> waterRateMap) {

    	final WSRequestDTO requestRateMaster = new WSRequestDTO();
        Map<Long, WaterRateMaster> rate = null;
        requestRateMaster.setDataModel(waterRateMap);
        final WSResponseDTO result = RestClient.callBRMS(requestRateMaster,
                ServiceEndpoints.BRMSMappingURL.WATER_RATE_BILL_URL);
        if ((result != null) && MainetConstants.WebServiceStatus.SUCCESS.equalsIgnoreCase(result.getWsStatus())) {
            rate = castResponseToRateMap(result);
        }

        return rate;
    }

    private WaterTaxCalculation populateTaxCalculationModel(TbCsmrInfoDTO waterDTO, TbTaxMas taxMas, LookUp taxType,
            Organisation orgnisation, WaterTaxCalculation taxCalculation) {
        setDefaultTaxClaculationData(taxCalculation, waterDTO);
        if (waterDTO.getCsCcncategory1() != null)
            taxCalculation.setConnectionType(CommonMasterUtility
                    .getHierarchicalLookUp(waterDTO.getCsCcncategory1(), orgnisation).getDescLangFirst());
        taxCalculation.setOrgId(orgnisation.getOrgid());
        taxCalculation.setTaxCode(taxMas.getTaxCode());
        return taxCalculation;
    }

    private WaterRateMaster populateRateMasterModel(TbCsmrInfoDTO waterDTO, TbTaxMas taxMas, LookUp taxCategory1,
            LookUp taxType, Organisation orgnisation, WaterRateMaster rateMaster, List<TbWtBillSchedule> billSchedule) {
		LOGGER.info("Begin--> " + this.getClass().getSimpleName() + " populateRateMasterModel() method ");

        setDefaultDependsOnFactorForRateCalculation(rateMaster, waterDTO, taxType.getDescLangFirst(),
                taxMas.getTaxCode(), orgnisation.getOrgid());
        List<String> dependFactorList = new ArrayList<>();
        taxMas.getTaxDetMasList().forEach(mas -> {
            if (StringUtils.equalsIgnoreCase(mas.getStatus(), MainetConstants.FlagA))
                dependFactorList
                        .add(CommonMasterUtility.findLookUpCode("SLD", orgnisation.getOrgid(), mas.getTdDependFact()));
        });
        if (CollectionUtils.isNotEmpty(dependFactorList)) {
            for (String dependFactor : dependFactorList) {
                if (StringUtils.equalsIgnoreCase(dependFactor, "CON")) {
                    if (waterDTO.getCsCcnsize() != null) {
                        rateMaster.setConnectionSize(Double.valueOf(
                                CommonMasterUtility.getNonHierarchicalLookUpObject(waterDTO.getCsCcnsize(), orgnisation)
                                        .getDescLangFirst()));
                    }
                }

                if (StringUtils.equalsIgnoreCase(dependFactor, "NOF")) {

                    if (waterDTO.getNoOfFamilies() != null) {
                        rateMaster.setNoOfFamilies(waterDTO.getNoOfFamilies().intValue());
                    }

                }
                if (StringUtils.equalsIgnoreCase(dependFactor, "NOU")) {
                    if (waterDTO.getCsNoofusers() != null) {
                        rateMaster.setNoOfRoomsORTabel(waterDTO.getCsNoofusers().doubleValue());
                    }
                }
                if (StringUtils.equalsIgnoreCase(dependFactor, "BPL")) {
                    rateMaster.setIsBPL(waterDTO.getBplFlag());
                }
                if (StringUtils.equalsIgnoreCase(dependFactor, "TAP")) {
                    if (waterDTO.getCsTaxPayerFlag() == null || waterDTO.getCsTaxPayerFlag().isEmpty()) {
                        rateMaster.setTaxPayer(MainetConstants.FlagN);
                    } else {
                        rateMaster.setTaxPayer(waterDTO.getCsTaxPayerFlag());
                    }
                }

                if (StringUtils.equalsIgnoreCase(dependFactor, "WTC")) {
                    if (waterDTO.getTrmGroup1() != null) {
                        final String usage1 = CommonMasterUtility
                                .getHierarchicalLookUp(waterDTO.getTrmGroup1(), orgnisation).getDescLangFirst();
                      //#135897 changes for interest calculation for ASCL Project
                      if (Utility.isEnvPrefixAvailable(orgnisation, MainetConstants.ENV_ASCL)) {
		            	if (taxMas.getTaxDesc().toUpperCase().contains(NewWaterServiceConstants.CCN_TYP_WTR)) {
                        rateMaster.setUsageSubtype1(usage1);
		            		
		            	}else if(taxMas.getTaxDesc().toUpperCase().contains(NewWaterServiceConstants.CCN_TYP_SEWER)) {
	                        rateMaster.setUsageSubtype1(NewWaterServiceConstants.SEWER);
		            	 }
                        }else {
                        	 rateMaster.setUsageSubtype1(usage1);	
                        }
                        if ((StringUtils.contains(CommonMasterUtility
                                .getHierarchicalLookUp(waterDTO.getTrmGroup1(), orgnisation).getLookUpCode(),
                                MainetConstants.FlagH)
                                || StringUtils.contains(CommonMasterUtility
                                        .getHierarchicalLookUp(waterDTO.getTrmGroup1(), orgnisation).getLookUpCode(),
                                        MainetConstants.NewWaterServiceConstants.RFC))
                                && waterDTO.getCsNoofusers() != null)
                            rateMaster.setFactor2(String.valueOf(waterDTO.getCsNoofusers()));

                    }
                    if (waterDTO.getTrmGroup2() != null) {
                        final String usage2 = CommonMasterUtility
                                .getHierarchicalLookUp(waterDTO.getTrmGroup2(), orgnisation).getDescLangFirst();
                        rateMaster.setUsageSubtype2(usage2);
                    }
                    if (waterDTO.getTrmGroup3() != null) {
                        final String usage3 = CommonMasterUtility
                                .getHierarchicalLookUp(waterDTO.getTrmGroup3(), orgnisation).getDescLangFirst();
                        rateMaster.setUsageSubtype3(usage3);
                    }
                    if (waterDTO.getTrmGroup4() != null) {
                        final String usage4 = CommonMasterUtility
                                .getHierarchicalLookUp(waterDTO.getTrmGroup4(), orgnisation).getDescLangFirst();
                        rateMaster.setUsageSubtype4(usage4);
                    }
                    if (waterDTO.getTrmGroup5() != null) {
                        final String usage5 = CommonMasterUtility
                                .getHierarchicalLookUp(waterDTO.getTrmGroup5(), orgnisation).getDescLangFirst();
                        rateMaster.setUsageSubtype5(usage5);
                    }

                }
            }
        }
        if (taxCategory1 != null) {
            rateMaster.setTaxCategory(taxCategory1.getDescLangFirst());
        }
        if (taxMas.getTaxCategory2() != null) {
            final String taxCategory2 = CommonMasterUtility.getHierarchicalLookUp(taxMas.getTaxCategory2(), orgnisation)
                    .getDescLangFirst();
            rateMaster.setTaxSubCategory(taxCategory2);
        }
        rateMaster.setTaxId(taxMas.getTaxId());
        if (!CollectionUtils.isEmpty(billSchedule)) {
            rateMaster.setFactor4(CommonMasterUtility
                    .getNonHierarchicalLookUpObject(billSchedule.get(0).getCnsCpdid(), orgnisation).getDescLangFirst());
        }

		if (waterDTO != null && waterDTO.getArv() != null) {
			rateMaster.setArv(waterDTO.getArv());
		} else {
			rateMaster.setArv(0);
		}
		LOGGER.info("End --> " + this.getClass().getSimpleName() + " populateRateMasterModel() method ");
        return rateMaster;

    }

    private Map<Long, TbWtExcessAmt> fetchBalanceAdvancePaymentData(final List<Long> csIdn, final long orgid) {
        final List<TbWtExcessAmt> advancePayment = tbWtExcessAmtJpaRepository.fetchBalanceAdvancePaymentData(csIdn,
                orgid);
        final Map<Long, TbWtExcessAmt> amt = new HashMap<>(0);
        if ((advancePayment != null) && !advancePayment.isEmpty()) {
            advancePayment.forEach(advanceAmt -> {
                amt.put(advanceAmt.getCsIdn(), advanceAmt);
            });
        }
        return amt;
    }

    /**
     * @param orgnisation
     * @param meterType
     * @return
     */
    private Date getBillDueDate(final Organisation orgnisation, final String meterType, BillTaxDTO billTax) {
        List<LookUp> billingMethod = null;
        billingMethod = CommonMasterUtility.getListLookup(PrefixConstants.WATERMODULEPREFIX.DDM, orgnisation);
        LookUp lookUpVal = null;
        if ((billingMethod != null) && !billingMethod.isEmpty()) {
            for (final LookUp lookUp : billingMethod) {
                if (lookUp.getDefaultVal().equals(PrefixConstants.IsLookUp.STATUS.YES)) {
                    lookUpVal = lookUp;
                    break;
                }
            }
        }
        if ((lookUpVal != null)
                && MainetConstants.NewWaterServiceConstants.BILL_SCHEDULE_DATE.equals(lookUpVal.getLookUpCode())) {
        	if(Utility.isEnvPrefixAvailable(orgnisation, MainetConstants.ENV_PSCL)) {
        		final Calendar cal = getBillingScheduleDueDate(meterType, orgnisation, new Date());
                return cal.getTime();
        	}else {
        		final Calendar cal = getBillingScheduleDueDate(meterType, orgnisation, billTax.getMrdTo());
                return cal.getTime();
        	}
            
        }else if ((lookUpVal != null)
                && MainetConstants.NewWaterServiceConstants.BILL_SCHEDULE_START_DATE.equals(lookUpVal.getLookUpCode())) {
            final Calendar cal = getBillingScheduleDueDate(meterType, orgnisation, billTax.getMrdFrom());
            return cal.getTime();
        }else if ((lookUpVal != null)
                && MainetConstants.NewWaterServiceConstants.BILL_SCHEDULE_END_DATE.equals(lookUpVal.getLookUpCode())) {
            final Calendar cal = getBillingScheduleDueDate(meterType, orgnisation, billTax.getMrdTo());
            return cal.getTime();
        }
        return null;
    }

    /**
     * @param orgnisation
     * @param errorListMap
     * @param empId
     */
    private void insertIntoErrorTable(final Organisation orgnisation,
            final Map<Long, WaterBillGenErrorDTO> errorListMap, final Long empId) {
        if (errorListMap != null && !errorListMap.isEmpty()) {
            for (final Entry<Long, WaterBillGenErrorDTO> error : errorListMap.entrySet()) {
                final WaterBillGenErrorDTO errorDtoData = error.getValue();
                errorDtoData.setOrgId(orgnisation.getOrgid());
                errorDtoData.setUserId(empId);
                insertIntoErrorTable(errorDtoData);
            }
        }
    }

    /**
     * @param errorListMap
     * @param errorDto
     * @param waterDTO
     * @param errorMsg
     */
    private void setErrorMap(final Map<Long, WaterBillGenErrorDTO> errorListMap, final WaterBillGenErrorDTO errorDto,
            final TbCsmrInfoDTO waterDTO, final String errorMsg) {
        errorDto.setConnumber(waterDTO.getCsCcn());
        errorDto.setCsIdn(waterDTO.getCsIdn());
        errorDto.setErrDate(new Date());
        errorDto.setErrMsg(errorMsg + waterDTO.getCsCcn());
        if (errorListMap != null) {
            errorListMap.put(waterDTO.getCsIdn(), errorDto);
        }
    }

    /**
     * @param meterType
     * @param dueDateDays
     * @param orgnisation
     * @param startDate
     * @return
     */
    @Override
    public Calendar getBillingScheduleDueDate(final String meterType, final Organisation orgnisation,
            final Date startDate) {
        final List<LookUp> dueDateDays = CommonMasterUtility.getListLookup(PrefixConstants.WATERMODULEPREFIX.DUE,
                orgnisation);
        final Calendar cal = Calendar.getInstance();
        cal.setTime(startDate);
        int days = 0;
        if (MainetConstants.NewWaterServiceConstants.METER.equals(meterType)) {
            for (final LookUp dueDays : dueDateDays) {
                if (MainetConstants.NewWaterServiceConstants.DUE_DATE_Meter.equals(dueDays.getOtherField())) {
                    days = Integer.valueOf(dueDays.getLookUpCode());
                    break;
                }
            }
        } else {
            for (final LookUp dueDays : dueDateDays) {
                if (MainetConstants.NewWaterServiceConstants.DUE_DATE_Non_Meter.equals(dueDays.getOtherField())) {
                    days = Integer.valueOf(dueDays.getLookUpCode());
                    break;
                }
            }
        }
        cal.add(Calendar.DATE, days);
        return cal;
    }

    /**
     * @param waterDTO
     * @param taxMas2
     * @param errorDto
     * @param taxCategory1
     * @param errorListMap
     * @param taxCalculation
     * @param taxCalMap
     * @param orgnisation
     * @param taxIdForRebate
     * @param taxIdForRebate
     * @param waterTaxAmountForRebate
     * @return
     * 
     */
    private void callWaterTaxCalculation(final TbTaxMas taxMas2, final TbCsmrInfoDTO waterDTO,
            final WaterBillGenErrorDTO errorDto, final LookUp taxCategory1, BillTaxDTO taxesCal,
            WaterTaxCalculation taxCalculation, final Map<Long, WaterBillGenErrorDTO> errorListMap,
            final Organisation orgnisation) {
    	LOGGER.info("Begin--> " + this.getClass().getSimpleName() + " callWaterTaxCalculation() method ");
        setDefaultTaxClaculationData(taxCalculation, waterDTO);
        taxCalculation.setOrgId(orgnisation.getOrgid());
        taxCalculation.setTaxCode(taxMas2.getTaxCode());
        final WSRequestDTO request = new WSRequestDTO();
        request.setDataModel(taxCalculation);
        final WSResponseDTO result = RestClient.callBRMS(request, ServiceEndpoints.BRMSMappingURL.WATER_TAX_URL);
        if ((result != null) && MainetConstants.WebServiceStatus.SUCCESS.equalsIgnoreCase(result.getWsStatus())) {
            List<Object> tax = null;
            try {
                tax = castResponseToTax(result);
            } catch (IOException e) {
                LOGGER.error("Error in tax calculation casting ", e);
            }
            taxCalculation = (WaterTaxCalculation) tax.get(0);
            taxesCal.setTax(taxCalculation.getTax());
        } else {
            final String errorMsg = ApplicationSession.getInstance().getMessage("water.bill.taxCalculation");
            setErrorMap(errorListMap, errorDto, waterDTO, errorMsg);
        }
        LOGGER.info("End--> " + this.getClass().getSimpleName() + " callWaterTaxCalculation() method ");
    }

    /**
     * @param taxCalculation
     * @param waterDTO
     */
    private void setDefaultTaxClaculationData(final WaterTaxCalculation taxCalculation, final TbCsmrInfoDTO waterDTO) {
        if (waterDTO.getNoOfFamilies() != null) {
            taxCalculation.setNoOfFamiliesFactor(waterDTO.getNoOfFamilies().doubleValue());
        }
        if (waterDTO.getCsNooftaps() != null) {
            taxCalculation.setNoOfTapsFactor(waterDTO.getCsNooftaps().doubleValue());
        }
        if (waterDTO.getCsNoofusers() != null) {
            taxCalculation.setNoOfRoomsORTabel(waterDTO.getCsNoofusers().doubleValue());
        }

    }

    public WaterRateMaster populateRatemaster(final TbCsmrInfoDTO waterDTO, final TbTaxMas taxMas,
            final LookUp taxCategory1, final LookUp taxType, final WaterBillGenErrorDTO errorDto,
            final WaterTaxCalculation taxCalculation, final Map<Long, WaterBillGenErrorDTO> errorListMap,
            final Organisation orgnisation, WaterRateMaster rateMaster, List<TbWtBillSchedule> billSchedule) {
    	LOGGER.info("Begin--> " + this.getClass().getSimpleName() + " populateRatemaster() method ");
        setDefaultDependsOnFactorForRateCalculation(rateMaster, waterDTO, taxType.getDescLangFirst(),
                taxMas.getTaxCode(), orgnisation.getOrgid());
        List<String> dependFactorList = new ArrayList<>();
        taxMas.getTaxDetMasList().forEach(mas -> {
            if (StringUtils.equalsIgnoreCase(mas.getStatus(), MainetConstants.FlagA))
                dependFactorList
                        .add(CommonMasterUtility.findLookUpCode("SLD", orgnisation.getOrgid(), mas.getTdDependFact()));
        });

        if (CollectionUtils.isNotEmpty(dependFactorList)) {
            for (String dependFactor : dependFactorList) {
                if (StringUtils.equalsIgnoreCase(dependFactor, "CON")) {
                    if (waterDTO.getCsCcnsize() != null) {
                        rateMaster.setConnectionSize(Double.valueOf(
                                CommonMasterUtility.getNonHierarchicalLookUpObject(waterDTO.getCsCcnsize(), orgnisation)
                                        .getDescLangFirst()));
                    }
                }

                if (StringUtils.equalsIgnoreCase(dependFactor, "NOF")) {

                    if (waterDTO.getNoOfFamilies() != null) {
                        rateMaster.setNoOfFamilies(waterDTO.getNoOfFamilies().intValue());
                    }

                }
                if (StringUtils.equalsIgnoreCase(dependFactor, "NOU")) {
                    if (waterDTO.getCsNoofusers() != null) {
                        rateMaster.setNoOfRoomsORTabel(waterDTO.getCsNoofusers().doubleValue());
                    }
                }
                if (StringUtils.equalsIgnoreCase(dependFactor, "BPL")) {
                    rateMaster.setIsBPL(waterDTO.getBplFlag());
                }

                if (StringUtils.equalsIgnoreCase(dependFactor, "TAP")) {
                    if (waterDTO.getCsTaxPayerFlag() == null || waterDTO.getCsTaxPayerFlag().isEmpty()) {
                        rateMaster.setTaxPayer(MainetConstants.FlagN);
                    } else {
                        rateMaster.setTaxPayer(waterDTO.getCsTaxPayerFlag());
                    }
                }

                if (StringUtils.equalsIgnoreCase(dependFactor, "WTC")) {
                    if (waterDTO.getTrmGroup1() != null) {
                        final String usage1 = CommonMasterUtility
                                .getHierarchicalLookUp(waterDTO.getTrmGroup1(), orgnisation).getDescLangFirst();
                        rateMaster.setUsageSubtype1(usage1);
                        if ((StringUtils.contains(CommonMasterUtility
                                .getHierarchicalLookUp(waterDTO.getTrmGroup1(), orgnisation).getLookUpCode(),
                                MainetConstants.FlagH)
                                || StringUtils.contains(CommonMasterUtility
                                        .getHierarchicalLookUp(waterDTO.getTrmGroup1(), orgnisation).getLookUpCode(),
                                        MainetConstants.NewWaterServiceConstants.RFC))
                                && waterDTO.getCsNoofusers() != null)
                            rateMaster.setFactor2(String.valueOf(waterDTO.getCsNoofusers()));
                    }
                    if (waterDTO.getTrmGroup2() != null) {
                        final String usage2 = CommonMasterUtility
                                .getHierarchicalLookUp(waterDTO.getTrmGroup2(), orgnisation).getDescLangFirst();
                        rateMaster.setUsageSubtype2(usage2);
                    }
                    if (waterDTO.getTrmGroup3() != null) {
                        final String usage3 = CommonMasterUtility
                                .getHierarchicalLookUp(waterDTO.getTrmGroup3(), orgnisation).getDescLangFirst();
                        rateMaster.setUsageSubtype3(usage3);
                    }
                    if (waterDTO.getTrmGroup4() != null) {
                        final String usage4 = CommonMasterUtility
                                .getHierarchicalLookUp(waterDTO.getTrmGroup4(), orgnisation).getDescLangFirst();
                        rateMaster.setUsageSubtype4(usage4);
                    }
                    if (waterDTO.getTrmGroup5() != null) {
                        final String usage5 = CommonMasterUtility
                                .getHierarchicalLookUp(waterDTO.getTrmGroup5(), orgnisation).getDescLangFirst();
                        rateMaster.setUsageSubtype5(usage5);
                    }
                }
            }
        }

        if (taxCategory1 != null) {
            rateMaster.setTaxCategory(taxCategory1.getDescLangFirst());
        }
        if (taxMas.getTaxCategory2() != null) {
            final String taxCategory2 = CommonMasterUtility.getHierarchicalLookUp(taxMas.getTaxCategory2(), orgnisation)
                    .getDescLangFirst();
            rateMaster.setTaxSubCategory(taxCategory2);
        }
        if (!CollectionUtils.isEmpty(billSchedule)) {
            rateMaster.setFactor4(CommonMasterUtility
                    .getNonHierarchicalLookUpObject(billSchedule.get(0).getCnsCpdid(), orgnisation).getDescLangFirst());
        }
        
		if (waterDTO != null && waterDTO.getArv() != null) {
			rateMaster.setArv(waterDTO.getArv());
		} else {
			rateMaster.setArv(0);
		}
		LOGGER.info("End--> " + this.getClass().getSimpleName() + " populateRatemaster() method ");
        return rateMaster;
    }

    /**
     * @param csIdn
     * @param taxMas
     * @param taxType
     * @param taxCategory1
     * @param meterReadingMap
     * @param errorDto
     * @param deptId
     * @param errorListMap
     * @param orgId
     * @param response
     * @return
     */
    private Map<Long, DemandNotice> getDemandNoticeData(final List<Long> csIdn, final long orgId) {
        final List<DemandNotice> demadNoticeData = demandNoticeGenarationRepository.getTaxCodeByConnectionId(csIdn,
                orgId);
        final Map<Long, DemandNotice> demandNotice = new HashMap<>(0);
        if ((demadNoticeData != null) && !demadNoticeData.isEmpty()) {
            demadNoticeData.forEach(notice -> {
                demandNotice.put(notice.getCsIdn(), notice);
            });
        }
        return demandNotice;
    }

    /**
     * @param result
     * @return
     * @throws IOException
     * @throws JsonParseException
     * @throws JsonMappingException
     */
    @SuppressWarnings("unchecked")
    private Map<Long, WaterRateMaster> castResponseToRateMap(final WSResponseDTO result) {
        Map<Long, WaterRateMaster> dataModel = null;
        LinkedHashMap<Long, Object> responseMap = (LinkedHashMap<Long, Object>) result.getResponseObj();

        String jsonString = new JSONObject(responseMap).toString();
        try {
            TypeReference<HashMap<Long, WaterRateMaster>> typeRef = new TypeReference<HashMap<Long, WaterRateMaster>>() {
            };
            dataModel = (Map<Long, WaterRateMaster>) new ObjectMapper().readValue(jsonString, typeRef);
        } catch (IOException e) {
            LOGGER.error("Error while casting model from WSRequestDTO water rate", e);
        }
        return dataModel;
    }

    /**
     * @param result
     * @return
     * @throws IOException
     * @throws JsonParseException
     * @throws JsonMappingException
     */
    @SuppressWarnings("unchecked")
    private List<Object> castResponseToRate(final WSResponseDTO result)
            throws IOException, JsonParseException, JsonMappingException {
        Object dataModel = null;
        LinkedHashMap<Long, Object> responseMap = null;
        final List<Object> dataModelList = new ArrayList<>();
        responseMap = (LinkedHashMap<Long, Object>) result.getResponseObj();
        final String jsonString = new JSONObject(responseMap).toString();
        dataModel = new ObjectMapper().readValue(jsonString, WaterRateMaster.class);
        dataModelList.add(dataModel);
        return dataModelList;
    }

    @SuppressWarnings("unchecked")
    private List<Object> castResponseToTax(final WSResponseDTO result)
            throws IOException, JsonParseException, JsonMappingException {
        Object dataModel = null;
        LinkedHashMap<Long, Object> responseMap = null;
        final List<Object> dataModelList = new ArrayList<>();
        responseMap = (LinkedHashMap<Long, Object>) result.getResponseObj();
        final String jsonString = new JSONObject(responseMap).toString();
        dataModel = new ObjectMapper().readValue(jsonString, WaterTaxCalculation.class);
        dataModelList.add(dataModel);
        return dataModelList;
    }

    /**
     * @param waterDTO
     * @param taxMas
     * @param taxType
     * @param taxCategory1
     * @param meterReadingMap
     * @param errorDto
     * @param deptId
     * @param errorListMap
     * @param orgnisation
     * @param rateMaster
     * @param dependsOnFactor
     * @param taxCalculation2
     * @return
     */
    private WaterRateMaster getGeneralAndPenaltyTax(final TbCsmrInfoDTO waterDTO, final TbTaxMas taxMas,
            final LookUp taxCategory1, final Organisation orgnisation, final WaterRateMaster rateMaster,Date manualDate) {
        if (waterDTO.getCsCcnsize() != null) {
            rateMaster.setConnectionSize(Double.valueOf(CommonMasterUtility
                    .getNonHierarchicalLookUpObject(waterDTO.getCsCcnsize(), orgnisation).getDescLangFirst()));
        }
        if (waterDTO.getTrmGroup1() != null) {
            final String usage1 = CommonMasterUtility.getHierarchicalLookUp(waterDTO.getTrmGroup1(), orgnisation)
                    .getDescLangFirst();
            rateMaster.setUsageSubtype1(usage1);
        }
        if (waterDTO.getTrmGroup2() != null) {
            final String usage2 = CommonMasterUtility.getHierarchicalLookUp(waterDTO.getTrmGroup2(), orgnisation)
                    .getDescLangFirst();
            rateMaster.setUsageSubtype2(usage2);
        }
        if (waterDTO.getTrmGroup3() != null) {
            final String usage3 = CommonMasterUtility.getHierarchicalLookUp(waterDTO.getTrmGroup3(), orgnisation)
                    .getDescLangFirst();
            rateMaster.setUsageSubtype3(usage3);
        }
        if (waterDTO.getTrmGroup4() != null) {
            final String usage4 = CommonMasterUtility.getHierarchicalLookUp(waterDTO.getTrmGroup4(), orgnisation)
                    .getDescLangFirst();
            rateMaster.setUsageSubtype4(usage4);
        }
        if (waterDTO.getTrmGroup5() != null) {
            final String usage5 = CommonMasterUtility.getHierarchicalLookUp(waterDTO.getTrmGroup5(), orgnisation)
                    .getDescLangFirst();
            rateMaster.setUsageSubtype5(usage5);
        }
        if (taxCategory1 != null) {
            rateMaster.setTaxCategory(taxCategory1.getDescLangFirst());
        }
        if (taxMas.getTaxCategory2() != null) {
            final String taxCategory2 = CommonMasterUtility.getHierarchicalLookUp(taxMas.getTaxCategory2(), orgnisation)
                    .getDescLangFirst();
            rateMaster.setTaxSubCategory(taxCategory2);
        }

        rateMaster.setRateStartDate(new Date().getTime());
        if (manualDate != null) {
        	rateMaster.setRateStartDate(manualDate.getTime());
        }
        
        DateFormat formatter = new SimpleDateFormat("dd/MM/yyyy");
        Date today = new Date();
        try {
			Date todayWithZeroTime = formatter.parse(formatter.format(today));
			rateMaster.setRateStartDate(todayWithZeroTime.getTime());
		} catch (ParseException e) {
			e.printStackTrace();
		}
        
        if (manualDate != null) {
        	try {
				Date todayWithZeroTimeForManual = formatter.parse(formatter.format(manualDate));
				rateMaster.setRateStartDate(todayWithZeroTimeForManual.getTime());
			} catch (ParseException e) {
				e.printStackTrace();
			}
        	
        }
        
        WaterRateMaster WaterRateMaster = null;
        final WSRequestDTO requestRateMaster = new WSRequestDTO();
        requestRateMaster.setDataModel(rateMaster);
        final WSResponseDTO result = RestClient.callBRMS(requestRateMaster,
                ServiceEndpoints.BRMSMappingURL.WATER_RATE_URL);
        if ((result != null) && MainetConstants.WebServiceStatus.SUCCESS.equalsIgnoreCase(result.getWsStatus())) {
            try {
                final List<Object> rate = castResponseToRate(result);
                WaterRateMaster = (WaterRateMaster) rate.get(0);
            } catch (final JsonParseException e) {
                LOGGER.error("error in water/getWaterRate" + e);
            } catch (final JsonMappingException e) {
                LOGGER.error("error in water/getWaterRate" + e);
            } catch (final IOException e) {
                LOGGER.error("error in water/getWaterRate" + e);
            }
        }
        return WaterRateMaster;
    }

    /**
     * @param waterDTO
     * @param meterReadingMap
     * @param errorDto
     * @param errorListMap
     * @param orgnisation
     * @param rateMaster
     * @param taxCalculation
     * @param billSchedule
     * @param meterType
     * @param cutOff
     * @param notPaidBills
     * @param exceptionalGapData
     */
    private void setMeterNonMeterData(final TbCsmrInfoDTO waterDTO, final BillTaxDTO meter,
            final WaterBillGenErrorDTO errorDto, final Map<Long, WaterBillGenErrorDTO> errorListMap,
            final Organisation orgnisation, final WaterRateMaster rateMaster, final WaterTaxCalculation taxCalculation,
            final LookUp meterType, final String billingMethod) {
    	LOGGER.info("Begin--> " + this.getClass().getSimpleName() + " setMeterNonMeterData() method ");
        final String connectionType = meterType.getDescLangFirst();
        rateMaster.setMeterType(connectionType);
        taxCalculation.setMeterType(connectionType);
        if (billingMethod != null) {
            taxCalculation.setBillingMethod(billingMethod);
        }
        if(meter.getNdays()!=null)
          rateMaster.setNoOfDays(meter.getNdays().doubleValue());
        taxCalculation.setNoOfDays(meter.getNdays());
        rateMaster.setRateStartDate(meter.getMrdFrom().getTime());
        rateMaster.setGapCode(meter.getCpdGap());
        final String typeOfPeriod = CommonMasterUtility
                .getNonHierarchicalLookUpObject(meter.getMrdCpdIdWtp(), orgnisation).getDescLangFirst();
        taxCalculation.setTypeOfPeriod(typeOfPeriod);
        if (MainetConstants.NewWaterServiceConstants.METER.equals(meterType.getLookUpCode())) {
            rateMaster.setConsumption(meter.getCsmp().doubleValue());
            taxCalculation.setConsumption(meter.getCsmp());
        }
    	LOGGER.info("End--> " + this.getClass().getSimpleName() + " setMeterNonMeterData() method ");
    }

    /**
     * @param response
     * @param request
     * @param waterDTO
     * @param taxCalculation
     * @param orgnisation
     * @param meterReadingMap
     * @param billSchedule
     * @param notPaidBills
     * @param exceptionalGapData
     * @param meterReadingMap
     * @param cutOff
     */
    private BillTaxDTO populateNonMeterDataForNoOfDays(final TbCsmrInfoDTO waterDTO, final Organisation orgnisation,
            final List<TbWtBillSchedule> billSchedule, final Boolean billPresent, final Long gapDays,
            final String meterType, final String billingMethod, final NoOfDays daysDTO, TbWtBillMasEntity billMas, FinancialYear financialYear) {
    	LOGGER.info("Begin--> " + this.getClass().getSimpleName() + " populateNonMeterDataForNoOfDays() method ");
        BillTaxDTO nonMeter = new BillTaxDTO();
        daysDTO.setOrgId(orgnisation.getOrgid());
        daysDTO.setTypeOfConnection(meterType);
        daysDTO.setBillingMethod(billingMethod);
        if (waterDTO.getPcDate() != null) {
            daysDTO.setPhysicalConnectionDate(waterDTO.getPcDate().getTime());
        }
        String prefixWtp = null;
       
        if ((null != billPresent && billPresent)) {
            prefixWtp = PrefixConstants.WATERMODULEPREFIX.RB;
        } else {
            prefixWtp = PrefixConstants.WATERMODULEPREFIX.FB;
        }
        if(waterDTO.getPcDate() != null) {
        	 Long physicalCnnYear = iFinancialYearService.getFinanceYearId(waterDTO.getPcDate());
        	 if(!physicalCnnYear.equals(financialYear.getFaYear())) {
        		 prefixWtp = PrefixConstants.WATERMODULEPREFIX.RB;
        	 }
        }
        if (gapDays != null) {
            daysDTO.setExceptionPeriod(gapDays);
        }
        final LookUp typeOfPeriod = CommonMasterUtility.getValueFromPrefixLookUp(prefixWtp,
                PrefixConstants.WATERMODULEPREFIX.WTP, orgnisation);
        daysDTO.setTypeOfPeriod(typeOfPeriod.getDescLangFirst());
        nonMeter.setMrdCpdIdWtp(typeOfPeriod.getLookUpId());
        List<Date> billScheduleDate = null;
        billScheduleDate = setBillScheduleStartAndEndForNonMeter(waterDTO, billSchedule, daysDTO, billScheduleDate,
                billMas, financialYear);
        if ((billScheduleDate != null) && !billScheduleDate.isEmpty()) {
            nonMeter.setMrdFrom(billScheduleDate.get(0));
            nonMeter.setMrdTo(billScheduleDate.get(1));
        }
        WSRequestDTO request = new WSRequestDTO();
        request.setDataModel(daysDTO);
        final WSResponseDTO result = RestClient.callBRMS(request, ServiceEndpoints.BRMSMappingURL.WATER_NO_OF_DAYS_URL);
        if ((result != null) && MainetConstants.WebServiceStatus.SUCCESS.equalsIgnoreCase(result.getWsStatus())) {
            nonMeter.setNdays(Long.valueOf(result.getResponseObj().toString()));
        }
    	LOGGER.info("End--> " + this.getClass().getSimpleName() + " populateNonMeterDataForNoOfDays() method ");
        return nonMeter;
    }

    /**
     * @param waterDTO
     * @param billSchedule
     * @param daysDTO
     * @param billScheduleDate
     * @return
     */
    private List<Date> setBillScheduleStartAndEndForNonMeter(final TbCsmrInfoDTO waterDTO,
            final List<TbWtBillSchedule> billSchedule, final NoOfDays daysDTO, List<Date> billScheduleDate,
            TbWtBillMasEntity billMas, FinancialYear financialYear) {
    	LOGGER.info("Begin--> " + this.getClass().getSimpleName() + " setBillScheduleStartAndEndForNonMeter() method ");
        if ((billSchedule != null) && !billSchedule.isEmpty()) {
            long ward1 = -1;
            long ward2 = -1;
            long ward3 = -1;
            long ward4 = -1;
            long ward5 = -1;

            long Schward1 = -1;
            long Schward2 = -1;
            long Schward3 = -1;
            long Schward4 = -1;
            long Schward5 = -1;
            for (final TbWtBillSchedule billsch : billSchedule) {
                if (MainetConstants.Common_Constant.NUMBER.ONE.equals(billsch.getDependsOnType())) {
                    if ((billsch.getCodIdWwz1() != null) && (billsch.getCodIdWwz1() > -1)) {
                        if (waterDTO.getCodDwzid1() != null) {
                            ward1 = waterDTO.getCodDwzid1().longValue();
                        }
                        if ((billsch.getCodIdWwz2() != null) && (billsch.getCodIdWwz2() > -1)) {
                            if (waterDTO.getCodDwzid2() != null) {
                                ward2 = waterDTO.getCodDwzid2().longValue();
                            }
                            if ((billsch.getCodIdWwz3() != null) && (billsch.getCodIdWwz3() > -1)) {
                                if (waterDTO.getCodDwzid3() != null) {
                                    ward3 = waterDTO.getCodDwzid3().longValue();
                                }
                                if ((billsch.getCodIdWwz4() != null) && (billsch.getCodIdWwz4() > -1)) {
                                    if (waterDTO.getCodDwzid4() != null) {
                                        ward4 = waterDTO.getCodDwzid4().longValue();
                                    }
                                    if ((billsch.getCodIdWwz5() != null) && (billsch.getCodIdWwz5() > -1)) {
                                        if (waterDTO.getCodDwzid5() != null) {
                                            ward5 = waterDTO.getCodDwzid5().longValue();
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (billsch.getCodIdWwz1() != null) {
                        Schward1 = billsch.getCodIdWwz1().longValue();
                    }
                    if (billsch.getCodIdWwz2() != null) {
                        Schward2 = billsch.getCodIdWwz2().longValue();
                    }
                    if (billsch.getCodIdWwz3() != null) {
                        Schward3 = billsch.getCodIdWwz3().longValue();
                    }
                    if (billsch.getCodIdWwz4() != null) {
                        Schward4 = billsch.getCodIdWwz4().longValue();
                    }
                    if (billsch.getCodIdWwz5() != null) {
                        Schward5 = billsch.getCodIdWwz5().longValue();
                    }
                    if ((ward1 == Schward1) && (ward2 == Schward2) && (ward3 == Schward3) && (ward4 == Schward4)
                            && (ward5 == Schward5)) {
                        // need to add schedule from last bill generated schedule
                        for (final TbWtBillScheduleDetail schDetail : billsch.getBillScheduleDetail()) {
                            billScheduleDate = getCycleStartandEnd(daysDTO, schDetail, billMas,financialYear);
                            if (billScheduleDate != null) {
                                break;
                            }
                        }
                    }
                } else if (MainetConstants.Common_Constant.NUMBER.TWO.equals(billsch.getDependsOnType())) {
                    if ((waterDTO.getCsCcncategory1() != null)
                            && waterDTO.getCsCcncategory1().equals(billsch.getCnsCcgid1())) {
                        for (final TbWtBillScheduleDetail schDetail : billsch.getBillScheduleDetail()) {
                            // need to add schedule from last bill generated schedule
                            billScheduleDate = getCycleStartandEnd(daysDTO, schDetail, billMas,financialYear);
                            if (billScheduleDate != null) {
                                break;
                            }
                        }
                    }
                }
            }
        }
        LOGGER.info("End--> " + this.getClass().getSimpleName() + " setBillScheduleStartAndEndForNonMeter() method ");
        return billScheduleDate;
    }

    /**
     * @param daysDTO
     * @param schDetail
     * @return
     */
    // Bills should be generated from last generated bill date from that schedule
    // onwards
    private List<Date> getCycleStartandEnd(final NoOfDays daysDTO, final TbWtBillScheduleDetail schDetail,
            TbWtBillMasEntity billMas,FinancialYear financialYear) {
        int start = 0;
        int end = 0;
        List<Date> datesRange = null;
        final String finYear = Utility.getCompleteFinancialYear(financialYear.getFaFromDate(),
        		financialYear.getFaToDate());
        start = schDetail.getCnsFromDate().intValue();
        end = schDetail.getCnsToDate().intValue();
        //final String finYear = Utility.getCurrentFinancialYear();
        final Date startDate = Utility.dateFromMonth(finYear, start, MainetConstants.FINYEAR_DATE.FIRST);
        final Date endDate = Utility.dateFromMonth(finYear, end, MainetConstants.FINYEAR_DATE.LAST);
        Date cur = getZeroTimeDate(new Date());
        if (billMas != null) {
            Date toDate = billMas.getBmTodt();
            if ((cur.compareTo(startDate) * toDate.compareTo(endDate)) <= 0) {
                datesRange = new ArrayList<>(0);
                daysDTO.setBillingCycleStartDate(startDate.getTime());
                daysDTO.setBillingCycleEndDate(endDate.getTime());
                datesRange.add(startDate);
                datesRange.add(endDate);
            }
        } else {
        	 Organisation org = new Organisation();
             org.setOrgid(schDetail.getOrgid());
        	if (Utility.isEnvPrefixAvailable(org, MainetConstants.ENV_SKDCL) || Utility.isEnvPrefixAvailable(org, MainetConstants.ENV_PSCL)) {  
        		datesRange = new ArrayList<>(0);
                daysDTO.setBillingCycleStartDate(startDate.getTime());
                daysDTO.setBillingCycleEndDate(endDate.getTime());
                datesRange.add(startDate);
                datesRange.add(endDate);
        	}else {
        		if ((cur.compareTo(startDate) * cur.compareTo(endDate)) <= 0) {
                    datesRange = new ArrayList<>(0);
                    daysDTO.setBillingCycleStartDate(startDate.getTime());
                    daysDTO.setBillingCycleEndDate(endDate.getTime());
                    datesRange.add(startDate);
                    datesRange.add(endDate);
        		}
        	}
        }
			
        
        return datesRange;
    }

    /**
     * @param waterDTO
     * @param rateMaster
     * @param taxCode
     * @param taxType
     * @param deptId
     * @param orgId
     * 
     */
    private void setDefaultDependsOnFactorForRateCalculation(final WaterRateMaster rateMaster,
            final TbCsmrInfoDTO waterDTO, final String taxType, final String taxCode, final long orgId) {
        rateMaster.setFinancialYear(Utility.getCurrentFinancialYear());
        rateMaster.setOrgId(orgId);
        rateMaster.setTaxType(taxType);
        rateMaster.setTaxCode(taxCode);
        // rateMaster.setIsBPL(waterDTO.getBplFlag());
        rateMaster.setDeptCode(MainetConstants.WATER_DEPARTMENT_CODE);
        /*
         * if (waterDTO.getNoOfFamilies() != null) { rateMaster.setNoOfFamilies(waterDTO.getNoOfFamilies().intValue()); } if
         * (waterDTO.getCsNoofusers() != null) { rateMaster.setNoOfRoomsORTabel(waterDTO.getCsNoofusers().doubleValue()); }
         */
    }

    /*
     * (non-Javadoc)
     * @see com.abm.mainetservice.water.service.TbWtBillMasService# getRebateAmountForPayment(com.abm.mainetservice.water.entity.
     * TbKCsmrInfoMH, com.abm.mainetservice.water.bean.TbWtBillMas)
     */
    @Override
    @Transactional
    public BillTaxDTO getRebateAmountForPayment(final TbCsmrInfoDTO dto, final TbBillMas watertax,
            final Organisation orgnisation,Date manualDate) {
    	LOGGER.info("Begin--> " + this.getClass().getSimpleName() + " getRebateAmountForPayment() method ");
        final LookUp chargeApplicableAt = CommonMasterUtility.getValueFromPrefixLookUp(
                PrefixConstants.LookUpPrefix.RCPT, PrefixConstants.NewWaterServiceConstants.CAA, orgnisation);
        final Long deptId = departmentService.getDepartmentIdByDeptCode(MainetConstants.WATER_DEPT,
                MainetConstants.STATUS.ACTIVE);
        final List<TbTaxMas> taxList = tbTaxMasService.findAllTaxesForBillGeneration(orgnisation.getOrgid(), deptId,
                chargeApplicableAt.getLookUpId(), null);
        BillTaxDTO rebate = new BillTaxDTO();
        rebate.setTax(0d);
        Double waterTaxAmountForRebate = 0d;
        for (final TbBillDet det : watertax.getTbWtBillDet()) {
            final String code = CommonMasterUtility.getHierarchicalLookUp(det.getTaxCategory(), orgnisation)
                    .getLookUpCode();
            if (code.equals(PrefixConstants.TAX_CATEGORY.DEMAND)) {
                /* if (watertax.getBmTotalAmount() == watertax.getBmTotalBalAmount()) { */
                waterTaxAmountForRebate += det.getBdCurTaxamt();
                /* } */
            }
        }
        if (waterTaxAmountForRebate > 0d) {
            final WaterBillGenErrorDTO errorDto = new WaterBillGenErrorDTO();
            if ((taxList != null) && !taxList.isEmpty()) {
                TbTaxMas taxMas = taxList.get(0);
                WaterTaxCalculation taxCalculation = null;
                WaterRateMaster rateMaster = null;
                LookUp taxType = null;
                LookUp taxCategory1 = null;
                if (taxMas.getTaxMethod() != null) {
                    taxType = CommonMasterUtility.getNonHierarchicalLookUpObject(Long.valueOf(taxMas.getTaxMethod()),
                            orgnisation);
                }
                if (taxMas.getTaxCategory1() != null) {
                    taxCategory1 = CommonMasterUtility.getHierarchicalLookUp(taxMas.getTaxCategory1(), orgnisation);
                }
                final WSRequestDTO request = new WSRequestDTO();
                request.setModelName("WaterRateMaster|WaterTaxCalculation");
                List<Object> waterRate = null;
                List<Object> waterTax = null;
                final WSResponseDTO response = RestClient.callBRMS(request,
                        ServiceEndpoints.BRMSMappingURL.INITIALIZE_MODEL_URL);
                if ((response != null) && MainetConstants.Req_Status.SUCCESS.equals(response.getWsStatus())) {
                    waterRate = RestClient.castResponse(response, WaterRateMaster.class, 0);
                    waterTax = RestClient.castResponse(response, WaterTaxCalculation.class, 1);
                    rateMaster = (WaterRateMaster) waterRate.get(0);
                    taxCalculation = (WaterTaxCalculation) waterTax.get(0);
                    rateMaster.setMeterType(CommonMasterUtility
                            .getNonHierarchicalLookUpObject(dto.getCsMeteredccn(), orgnisation).getDescLangFirst());
                    rateMaster.setChargeApplicableAt(chargeApplicableAt.getDescLangFirst());
                    taxCalculation.setMeterType(rateMaster.getMeterType());
                    rateMaster.setTaxId(taxMas.getTaxId());
                    setDefaultDependsOnFactorForRateCalculation(rateMaster, dto, taxType.getDescLangFirst(),
                            taxMas.getTaxCode(), orgnisation.getOrgid());
                    LookUp waterRebateAdvancePayment = null;
           			try {
           				waterRebateAdvancePayment = CommonMasterUtility.getValueFromPrefixLookUp("APR", "WRB", orgnisation);
           			}catch (Exception exception) {
           			}
           			if(waterRebateAdvancePayment != null && StringUtils.isNotBlank(waterRebateAdvancePayment.getOtherField())) {
           				long noOfMonths = Long.valueOf(waterRebateAdvancePayment.getOtherField());
           				int noOfMonthsRebate = (int) noOfMonths;
           				rateMaster.setNoOfMonthsRebate(noOfMonthsRebate);
           			}
                    rateMaster = getGeneralAndPenaltyTax(dto, taxMas, taxCategory1, orgnisation, rateMaster,manualDate);
                    if (rateMaster != null) {
                        rebate.setTaxId(taxMas.getTaxId());
                        rebate.setTaxCategory(taxMas.getTaxCategory1());
                        rebate.setTaxSequence(taxMas.getCollSeq());
                        if(taxMas.getParentCode() != null) {
                        	TbTaxMas tbTax = tbTaxMasService.findTaxByTaxIdAndOrgId(taxMas.getParentCode(), taxMas.getOrgid());
                            rebate.setParentTaxCode(tbTax.getTaxCode());
                        }
                        WaterCommonUtility.getAndSetBaseRate(rateMaster.getConsumption(), rateMaster, taxCalculation,
                                taxType.getLookUpCode());
                        taxCalculation.setGeneralTax(waterTaxAmountForRebate);
						callWaterTaxCalculation(taxMas, dto, errorDto, taxCategory1, rebate, taxCalculation, null,
								orgnisation);
                    }
                }
            }
        }
        LOGGER.info("End--> " + this.getClass().getSimpleName() + " getRebateAmountForPayment() method ");
        return rebate;
    }

    /*
     * (non-Javadoc)
     * @see com.abm.mainetservice.water.service.TbWtBillMasService# getRebateAmountForPaymentByCnTyp(com.abm.mainetservice.water.entity.
     * TbKCsmrInfoMH, com.abm.mainetservice.water.bean.TbWtBillMas)
     */
    @Override
    @Transactional
    public BillTaxDTO getRebateAmountForPaymentByCnTyp(final TbCsmrInfoDTO dto, final TbBillMas watertax,
            final Organisation orgnisation,Date manualDate) {
    	LOGGER.info("Begin--> " + this.getClass().getSimpleName() + " getRebateAmountForPayment() method ");
        final LookUp chargeApplicableAt = CommonMasterUtility.getValueFromPrefixLookUp(
                PrefixConstants.LookUpPrefix.RCPT, PrefixConstants.NewWaterServiceConstants.CAA, orgnisation);
        final Long deptId = departmentService.getDepartmentIdByDeptCode(MainetConstants.WATER_DEPT,
                MainetConstants.STATUS.ACTIVE);
        List<TbTaxMas> taxList = tbTaxMasService.findAllTaxesForBillGeneration(orgnisation.getOrgid(), deptId,
                chargeApplicableAt.getLookUpId(), null);
        
        final LookUp lookUp = CommonMasterUtility.getNonHierarchicalLookUpObject(dto.getCsCcnsize(), orgnisation);

        String ccnTyp = lookUp.getLookUpCode().equals(PrefixConstants.NewWaterServiceConstants.SWR) ? PrefixConstants.NewWaterServiceConstants.CCN_TYP_SEWER : 
        	NewWaterServiceConstants.CCN_TYP_WTR ;
        
        List<TbTaxMas> taxListTemp= new ArrayList<TbTaxMas>();
        
        for(TbTaxMas taxMasTemp : taxList)
        {
        	if(taxMasTemp.getTaxDesc().toUpperCase().contains(ccnTyp))
        	{
        		taxListTemp.add(taxMasTemp);
        	}
        }
        
        taxList = taxListTemp;
        
        
        BillTaxDTO rebate = new BillTaxDTO();
        rebate.setTax(0d);
        Double waterTaxAmountForRebate = 0d;
        for (final TbBillDet det : watertax.getTbWtBillDet()) {
            final String code = CommonMasterUtility.getHierarchicalLookUp(det.getTaxCategory(), orgnisation)
                    .getLookUpCode();
            if (code.equals(PrefixConstants.TAX_CATEGORY.DEMAND)) {
                /* if (watertax.getBmTotalAmount() == watertax.getBmTotalBalAmount()) { */
                waterTaxAmountForRebate += det.getBdCurTaxamt();
                /* } */
            }
        }
        if (waterTaxAmountForRebate > 0d) {
            final WaterBillGenErrorDTO errorDto = new WaterBillGenErrorDTO();
            if ((taxList != null) && !taxList.isEmpty()) {
                TbTaxMas taxMas = taxList.get(0);
                WaterTaxCalculation taxCalculation = null;
                WaterRateMaster rateMaster = null;
                LookUp taxType = null;
                LookUp taxCategory1 = null;
                if (taxMas.getTaxMethod() != null) {
                    taxType = CommonMasterUtility.getNonHierarchicalLookUpObject(Long.valueOf(taxMas.getTaxMethod()),
                            orgnisation);
                }
                if (taxMas.getTaxCategory1() != null) {
                    taxCategory1 = CommonMasterUtility.getHierarchicalLookUp(taxMas.getTaxCategory1(), orgnisation);
                }
                final WSRequestDTO request = new WSRequestDTO();
                request.setModelName("WaterRateMaster|WaterTaxCalculation");
                List<Object> waterRate = null;
                List<Object> waterTax = null;
                final WSResponseDTO response = RestClient.callBRMS(request,
                        ServiceEndpoints.BRMSMappingURL.INITIALIZE_MODEL_URL);
                if ((response != null) && MainetConstants.Req_Status.SUCCESS.equals(response.getWsStatus())) {
                    waterRate = RestClient.castResponse(response, WaterRateMaster.class, 0);
                    waterTax = RestClient.castResponse(response, WaterTaxCalculation.class, 1);
                    rateMaster = (WaterRateMaster) waterRate.get(0);
                    taxCalculation = (WaterTaxCalculation) waterTax.get(0);
                    rateMaster.setMeterType(CommonMasterUtility
                            .getNonHierarchicalLookUpObject(dto.getCsMeteredccn(), orgnisation).getDescLangFirst());
                    rateMaster.setChargeApplicableAt(chargeApplicableAt.getDescLangFirst());
                    taxCalculation.setMeterType(rateMaster.getMeterType());
                    rateMaster.setTaxId(taxMas.getTaxId());
                    setDefaultDependsOnFactorForRateCalculation(rateMaster, dto, taxType.getDescLangFirst(),
                            taxMas.getTaxCode(), orgnisation.getOrgid());
                    LookUp waterRebateAdvancePayment = null;
           			try {
           				waterRebateAdvancePayment = CommonMasterUtility.getValueFromPrefixLookUp("APR", "WRB", orgnisation);
           			}catch (Exception exception) {
           			}
           			if(waterRebateAdvancePayment != null && StringUtils.isNotBlank(waterRebateAdvancePayment.getOtherField())) {
           				long noOfMonths = Long.valueOf(waterRebateAdvancePayment.getOtherField());
           				int noOfMonthsRebate = (int) noOfMonths;
           				rateMaster.setNoOfMonthsRebate(noOfMonthsRebate);
           			}
                    rateMaster = getGeneralAndPenaltyTax(dto, taxMas, taxCategory1, orgnisation, rateMaster,manualDate);
                    if (rateMaster != null) {
                        rebate.setTaxId(taxMas.getTaxId());
                        rebate.setTaxCategory(taxMas.getTaxCategory1());
                        rebate.setTaxSequence(taxMas.getCollSeq());
                        if(taxMas.getParentCode() != null) {
                        	TbTaxMas tbTax = tbTaxMasService.findTaxByTaxIdAndOrgId(taxMas.getParentCode(), taxMas.getOrgid());
                            rebate.setParentTaxCode(tbTax.getTaxCode());
                        }
                        WaterCommonUtility.getAndSetBaseRate(rateMaster.getConsumption(), rateMaster, taxCalculation,
                                taxType.getLookUpCode());
                        taxCalculation.setGeneralTax(waterTaxAmountForRebate);
						callWaterTaxCalculation(taxMas, dto, errorDto, taxCategory1, rebate, taxCalculation, null,
								orgnisation);
                    }
                }
            }
        }
        LOGGER.info("End--> " + this.getClass().getSimpleName() + " getRebateAmountForPayment() method ");
        return rebate;
    }

    
    @Override
    @Transactional(readOnly = true)
    public List<Object[]> fetchConnectionDataAndBillId(final Long csIdn, final Long orgid) {
        final List<Object[]> data = tbWtBillMasJpaRepository.fetchConnectionDataAndBillId(csIdn, orgid);
        return data;
    }

    @Override
    @Transactional
    public void updateBillGeneratedFlagInMeter(final Set<Long> connectionids, final long orgnisation) {
        tbMrdataJpaRepository.updateBillGeneratedFlagInMeter(connectionids, orgnisation);
    }

    @Override
    @Transactional(readOnly = true)
    public boolean validateBillPresentOrNot(final Long mmMtnid, final long orgid, final int month) {

        final Date endDate = Utility.dateFromMonth(Utility.getCurrentFinancialYear(), month,
                MainetConstants.FINYEAR_DATE.LAST);
        final String bmNo = tbMrdataJpaRepository.validateBillPresentOrNot(mmMtnid, orgid, endDate);
        if ((bmNo != null) && !bmNo.isEmpty()) {
            return true;
        } else {
            return false;
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<TbBillMas> getBillMasByConnectionId(Long csIdn) {
        List<TbWtBillMasEntity> entity = tbWtBillMasJpaRepository.getBillMasByConnectionId(csIdn);
        List<TbBillMas> billMasList = new ArrayList<>(0);
        for (TbWtBillMasEntity billMas : entity) {
            TbBillMas billMasDTO = new TbBillMas();
            List<TbBillDet> billDetailList = new ArrayList<>(0);
            BeanUtils.copyProperties(billMas, billMasDTO);
            for (TbWtBillDetEntity det : billMas.getBillDetEntity()) {
                TbBillDet billDetailsDTO = new TbBillDet();
                BeanUtils.copyProperties(det, billDetailsDTO);
                billDetailsDTO.setBdCsmp(BigDecimal.valueOf(Utility.round(det.getBdCurBalTaxamt(), 2)));
                billDetailList.add(billDetailsDTO);
            }
            billMasDTO.setTbWtBillDet(billDetailList);
            billMasList.add(billMasDTO);
        }
        return billMasList;
    }

    /**
     * To save Duplicate Bill
     * 
     * @param List<TbWtBillMasEntity>
     */
    private void saveDuplicateBill(Map<Long, WaterBillPrintingDTO> printData, Long orgId, Long empId,
            String ipAddress) {
        DuplicateBillDTO dto = null;
        List<DuplicateBillDTO> dupList = new ArrayList<>();
        for (Map.Entry<Long, WaterBillPrintingDTO> entry : printData.entrySet()) {
            dto = new DuplicateBillDTO();
            final WaterBillPrintingDTO entity = entry.getValue();
            dto.setBmId(entity.getBmIdno());
            dto.setBillDate(entity.getBmBilldt());
            dto.setBillFromDate(entity.getBmFromdt());
            dto.setBillToDate(entity.getBmTodt());
            dto.setBmYear(entity.getBmYear());
            dto.setCreatedBy(empId);
            dto.setCreatedDate(new Date());
            dto.setDeptCode(MainetConstants.DEPT_SHORT_NAME.WATER);
            dto.setLgIpMac(ipAddress);
            dto.setOrgId(orgId);
            dto.setReferenceId(entity.getWaterMas().getCsCcn());
            try {
                dto.setDupBillData(new ObjectMapper().writeValueAsString(entity));
                dupList.add(dto);

            } catch (IOException e) {
                throw new FrameworkException("Error While Casting Object in String for k() " + e);
            }

        }
        duplicateBillService.save(dupList);
    }

    @Override
    @Transactional
	public WaterPenaltyDto calculateSurcharge(Organisation organisation, Long deptId, List<TbBillMas> billMasList,
			TbTaxMas taxMas, Long finYearId, TbCsmrInfoDTO csmrInfoDto, String ipAddress, Long userId,String billGenFlag,Date manualReceiptDate) {
    	LOGGER.info("Begin--> " + this.getClass().getSimpleName() + " calculateSurcharge() method ");
        WaterPenaltyDto waterSurCharge = null;
        WaterBillTaxDTO surchargeTaxDto = null;
        Date dueDateCrossed = new Date();
        int noOfMonthsSurcharge = 0;
        if(manualReceiptDate != null) {
        	dueDateCrossed = manualReceiptDate;
        }
        int size = billMasList.size() - 1;
        double totalArrear = 0;
        
        TbBillMas billMaster = null;
        TbBillMas previousBillMas = null;
        Long bmIdNo = 0L;
        if (csmrInfoDto.getCsIdn() != 0) {
            waterSurCharge = waterPenaltyService.getWaterPenaltyByCCNOByFinId(String.valueOf(csmrInfoDto.getCsIdn()),
                    finYearId, organisation.getOrgid());
            LOGGER.info("Checking Surcharge Calculated aginst particular connection No. and current finanYear",
                    waterSurCharge);
        }
        LOGGER.info("calculateSurcharge method ---> check for prefix start");
        boolean covidActiveFlag = checkDaysExtendedCovidActive(organisation);
        LOGGER.info("calculateSurcharge method ---> check for prefix ends");
        
      //get all not paid bills for suda
        if(Utility.isEnvPrefixAvailable(organisation, MainetConstants.ENV_SUDA ) && waterSurCharge == null) {
        	billMasList = billMasterService.getBillMasListByCsidn(csmrInfoDto.getCsIdn(), organisation.getOrgid());
        	if(billMasList != null && !billMasList.isEmpty())
        		billMasList = billMasList.stream().filter(bill -> "N".equals(bill.getBmPaidFlag())).collect(Collectors.toList());
        	else
        		LOGGER.info("calculateSurcharge method ---> billmaslist empty for csidn: "+csmrInfoDto.getCsIdn());
        }
        
        // If no surcharge is calculated for current fin year then inserting new entry
        if (waterSurCharge == null) {
        	if(CollectionUtils.isNotEmpty(billMasList)) {
        		for (TbBillMas billMas : billMasList) {
					if(Utility.compareDate(billMas.getBmDuedate(), dueDateCrossed) && !Utility.comapreDates(billMas.getBmDuedate(), dueDateCrossed)) {
						if(covidActiveFlag) {
							LOGGER.info("calculateSurcharge method ---> get arrears if penalty save start");
							totalArrear = totalArrear + arrearAmountIfCovidActive(organisation, billMas, finYearId, dueDateCrossed);
							bmIdNo = billMas.getBmIdno();
							LOGGER.info("calculateSurcharge method ---> get arrears if penalty save ends");
						}
						else {
							totalArrear = totalArrear + billMas.getBmTotalBalAmount();
							bmIdNo = billMas.getBmIdno();
							if(billMas.getBmTotalBalAmount() > 0) {
								int monthsBetweenDates = monthsBetweenDates(billMas.getBmFromdt(), billMas.getBmTodt()) + 1;
								noOfMonthsSurcharge = noOfMonthsSurcharge + monthsBetweenDates;
							}
						}
						
						previousBillMas = billMaster;
						billMaster = billMas;
					}
				}
        		
        	}
        	
            if(billMaster != null && excludeLastBillAmount(billMaster, organisation, dueDateCrossed)) {
            	totalArrear = totalArrear - billMaster.getBmTotalBalAmount();
            	if(previousBillMas != null) {
            		billMaster = previousBillMas;
            		bmIdNo = billMaster.getBmIdno();
            	}
            }
            if (totalArrear > 0) {
                // Here fetching charges from BRMS Sheet and calculating
                LOGGER.info("Starts Surcharge Calculation from BRMS Sheet");
            	surchargeTaxDto = fetchSurCharge(organisation, deptId, totalArrear, taxMas, csmrInfoDto,noOfMonthsSurcharge);
                // Here setting the data to save in penalty table
                if (surchargeTaxDto != null) {

                    waterSurCharge = new WaterPenaltyDto();

                    waterSurCharge.setConnNo(String.valueOf(csmrInfoDto.getCsIdn()));
                    waterSurCharge.setBmIdNo(bmIdNo);
                    waterSurCharge.setCreateddate(new Date());
                    waterSurCharge.setCretedBy(userId);
                    waterSurCharge.setLgIpmac(ipAddress);
                    waterSurCharge.setOrgId(organisation.getOrgid());
                    waterSurCharge.setTaxId(surchargeTaxDto.getTaxId());
                    waterSurCharge.setActualAmount(surchargeTaxDto.getTaxAmount());
                    waterSurCharge.setPendingAmount(surchargeTaxDto.getTaxAmount());
                    waterSurCharge.setActualArrrearAmount(totalArrear);
                    if(billMaster != null) {
                    	 waterSurCharge.setSurchargeFromDate(billMasList.get(0).getBmFromdt());
                         waterSurCharge.setSurchargeToDate(billMaster.getBmTodt());
                         waterSurCharge.setFinYearId(billMaster.getBmYear());
                    }else {
                    	 waterSurCharge.setFinYearId(finYearId);
                    }
                    if(StringUtils.isNotBlank(billGenFlag) && StringUtils.equals(billGenFlag, MainetConstants.FlagY)) {
                    	waterSurCharge.setBillGenAmount(surchargeTaxDto.getTaxAmount());
                    	waterSurCharge.setCurrBmIdNo(billMasList.get(billMasList.size() - 1).getBmIdno());
                    }
                    if(StringUtils.isNotBlank(billGenFlag) && StringUtils.equals(billGenFlag, MainetConstants.FlagY)) {
                    waterPenaltyService.saveWaterPenalty(waterSurCharge);
                    LOGGER.info("SurCharge Details saved Successfully");
                    }
                }

            }
        }

        // if any bill generated after calculating surcharge for current financial year
        // then updating the surcharge
        else {

           Long lastBillSurBillId = waterSurCharge.getBmIdNo();
        	
           if(CollectionUtils.isNotEmpty(billMasList)) {
				for (TbBillMas billMas : billMasList) {
					if (Utility.compareDate(billMas.getBmDuedate(), dueDateCrossed)
							&& !Utility.comapreDates(billMas.getBmDuedate(), dueDateCrossed)
							&& (((manualReceiptDate != null
									&& (((waterSurCharge.getBillGenAmount() != null)
											&& (waterSurCharge.getActualAmount() == waterSurCharge.getBillGenAmount()))
											|| (Utility.compareDate(waterSurCharge.getSurchargeToDate(),
													manualReceiptDate) && billMas.getBmIdno() > lastBillSurBillId))
									|| (manualReceiptDate != null
											&& (Utility.compareDate(manualReceiptDate,
													waterSurCharge.getSurchargeToDate()))
											&& waterSurCharge.getBillGenAmount() != null
											&& ((waterSurCharge.getBillGenAmount() != null) && (waterSurCharge
													.getActualAmount() == waterSurCharge.getBillGenAmount())))))
									|| (manualReceiptDate == null && billMas.getBmIdno() > lastBillSurBillId))) {

						if(covidActiveFlag) {
							LOGGER.info("calculateSurcharge method ---> get arrears if penalty update start");
							totalArrear = totalArrear + arrearAmountIfCovidActive(organisation, billMas, finYearId, dueDateCrossed);
							lastBillSurBillId = billMas.getBmIdno();
							LOGGER.info("calculateSurcharge method ---> get arrears if penalty update start");
						}
						else {
							totalArrear = totalArrear + billMas.getBmTotalBalAmount();
							lastBillSurBillId = billMas.getBmIdno();
							if(billMas.getBmTotalBalAmount() > 0) {
								int monthsBetweenDates = monthsBetweenDates(billMas.getBmFromdt(), billMas.getBmTodt()) + 1;
								noOfMonthsSurcharge = noOfMonthsSurcharge + monthsBetweenDates;
								
								
							}
						}
						previousBillMas = billMaster;
						billMaster = billMas;
					}
				}
       	}
           
           if(billMaster != null && excludeLastBillAmount(billMaster, organisation, dueDateCrossed)) {
           	totalArrear = totalArrear - billMaster.getBmTotalBalAmount();
           	if(previousBillMas != null) {
        		billMaster = previousBillMas;
        		lastBillSurBillId = billMaster.getBmIdno();
        	}
           }
            if (totalArrear > 0) {
            	surchargeTaxDto = fetchSurCharge(organisation, deptId, totalArrear, taxMas, csmrInfoDto, noOfMonthsSurcharge); 
         				
                if (surchargeTaxDto != null) {
                	waterSurCharge.setActualArrrearAmount(totalArrear);
                	if(manualReceiptDate != null) {
                		waterSurCharge.setActualAmount(surchargeTaxDto.getTaxAmount());
                    	waterSurCharge.setPendingAmount(surchargeTaxDto.getTaxAmount());
                	}else {
            			waterSurCharge.setActualAmount(waterSurCharge.getActualAmount()+surchargeTaxDto.getTaxAmount());
                    	waterSurCharge.setPendingAmount(waterSurCharge.getPendingAmount()+surchargeTaxDto.getTaxAmount());
                	}
                	
                	 if(StringUtils.isNotBlank(billGenFlag) && StringUtils.equals(billGenFlag, MainetConstants.FlagY)) {
                		 if(waterSurCharge.getBillGenAmount() != null) {
                			 waterSurCharge.setBillGenAmount(waterSurCharge.getBillGenAmount() + surchargeTaxDto.getTaxAmount());
                			 waterSurCharge.setCurrBmIdNo(billMasList.get(billMasList.size() - 1).getBmIdno());
                		 }else {
                			 waterSurCharge.setBillGenAmount(surchargeTaxDto.getTaxAmount());
                		 }
                     }
                	 // Here setting the data to update in penalty table
                     waterSurCharge.setBmIdNo(lastBillSurBillId);
                     waterSurCharge.setUpdatedBy(userId);
                     waterSurCharge.setLgIpMacUpd(ipAddress);
                     if(billMaster != null && billMaster.getBmYear() != null) {
                     	waterSurCharge.setFinYearId(billMaster.getBmYear());
                     }
                     if(billMaster != null) {
                     	waterSurCharge.setSurchargeFromDate(waterSurCharge.getSurchargeToDate());
                        waterSurCharge.setSurchargeToDate(billMaster.getBmTodt());
                     }
                     if(StringUtils.isNotBlank(billGenFlag) && StringUtils.equals(billGenFlag, MainetConstants.FlagY)) {
	                     waterPenaltyService.updateWaterPenalty(waterSurCharge);
	                     LOGGER.info("SurCharge Details Updated Successfully");
                     }
                }
            }
            
        }
        LOGGER.info("End--> " + this.getClass().getSimpleName() + " calculateSurcharge() method ");
        return waterSurCharge;
    }

    @Override
    @Transactional
    public WaterBillTaxDTO fetchSurCharge(Organisation org, Long deptId, double arrearAmt, TbTaxMas taxMas,
            TbCsmrInfoDTO csmrInfoDto,int noOfMonthSurcharge) {
    	LOGGER.info("Begin --> " + this.getClass().getSimpleName() + " fetchSurCharge() method ");
        WaterBillTaxDTO taxDto = null;
        WSRequestDTO requestDto = new WSRequestDTO();
        final LookUp chargeApplicableAt;
        if (Utility.isEnvPrefixAvailable(org, MainetConstants.ENV_PSCL)) {
        	chargeApplicableAt = CommonMasterUtility.getValueFromPrefixLookUp(
        		PrefixConstants.NewWaterServiceConstants.BILL, PrefixConstants.NewWaterServiceConstants.CAA, org);
        }else {
        	chargeApplicableAt = CommonMasterUtility.getValueFromPrefixLookUp(
            		PrefixConstants.NewWaterServiceConstants.BILL_RECEIPT, PrefixConstants.NewWaterServiceConstants.CAA, org);
        }
        LookUp taxType = CommonMasterUtility.getNonHierarchicalLookUpObject(Long.valueOf(taxMas.getTaxMethod()), org);

        LookUp taxCategory1 = CommonMasterUtility.getHierarchicalLookUp(taxMas.getTaxCategory1(), org);

        requestDto.setModelName("WaterRateMaster");

        // Initializing the model
        WSResponseDTO response = RestClient.callBRMS(requestDto, ServiceEndpoints.BRMSMappingURL.INITIALIZE_MODEL_URL);

        if (response != null && MainetConstants.Req_Status.SUCCESS.equalsIgnoreCase(response.getWsStatus())) {
            List<Object> waterRate = RestClient.castResponse(response, WaterRateMaster.class, 0);

            WaterRateMaster rateMaster = (WaterRateMaster) waterRate.get(0);

            Map<Long, WaterRateMaster> waterRateMap = new LinkedHashMap<>(0);

            final LookUp meterType = CommonMasterUtility.getNonHierarchicalLookUpObject(csmrInfoDto.getCsMeteredccn(),
                    org);
            
            
            // #139167 Akshata Bhat 
            LookUp taxBill = null;
            if(MainetConstants.ComparamMasterConstants.DISHONOUR_CHARGE.equals(taxMas.getTaxDesc())) {
            	taxBill = CommonMasterUtility.getValueFromPrefixLookUp(PrefixConstants.NewWaterServiceConstants.BILL,
            			PrefixConstants.NewWaterServiceConstants.CAA, org);
            }
          
            rateMaster.setChargeApplicableAt(taxBill != null? taxBill.getDescLangFirst() : chargeApplicableAt.getDescLangFirst());
            // #139167 Akshata Bhat

            //rateMaster.setChargeApplicableAt(chargeApplicableAt.getDescLangFirst());
            
            rateMaster.setMeterType(meterType.getDescLangFirst());
            rateMaster.setNoOfMonthsSurcharge(noOfMonthSurcharge);

			if (Utility.isEnvPrefixAvailable(org, MainetConstants.ENV_SKDCL)) {
				rateMaster.setRateStartDate(new Date().getTime());
				arrearAmt = arrearAmt * noOfMonthSurcharge;
			}

			// Here setting the data which are required to call BRMS Sheet
			waterRateMap.put(taxMas.getTaxId(),
					populateRateMasterModel(csmrInfoDto, taxMas, taxCategory1, taxType, org, rateMaster, null));

            // Here Calling BRMS Sheet and returns the baseRate and Flat Rate
            Map<Long, WaterRateMaster> waterRates = calculateRateMasterBRMS(waterRateMap);

            if (MapUtils.isNotEmpty(waterRates)) {

                Entry<Long, WaterRateMaster> waterRateMaster = waterRates.entrySet().iterator().next();
                double baseRate = 0;
                double totalSurcharge = 0;

                // Here checking Type of Tax whether Flat or Percentage
                if (StringUtils.isNotBlank(taxMas.getTaxMethod())) {

                    if (taxType.getLookUpCode().equals(PrefixConstants.TAX_TYPE.PERCENTAGE)) {
                    	baseRate = waterRateMaster.getValue().getPercentageRate() / 100;
                        totalSurcharge = baseRate * arrearAmt;
                    }
                    	
                    if (taxType.getLookUpCode().equals(PrefixConstants.TAX_TYPE.FLAT)) {
                        baseRate = waterRateMaster.getValue().getFlatRate();
                        totalSurcharge = baseRate;
                    }
                }
                // Here setting the data to display on screen
                if (totalSurcharge > 0) {
                    taxDto = new WaterBillTaxDTO();
                    taxDto.setTaxAmount(Math.round(totalSurcharge));
                    taxDto.setTaxdescription(taxMas.getTaxDesc());
                    
                    taxDto.setBalabceTaxAmount(Math.round(totalSurcharge));
                    taxDto.setTotal(Math.round(totalSurcharge));
					taxDto.setTaxId(taxMas.getTaxId());
                }
            } else {
                LOGGER.info("error message tax not calculated , rule not found for Surcharge");
                throw new FrameworkException("Rule Not Found for Sur Charge");
            }
        }
        LOGGER.info("Here returning WaterBillTaxDTO After Calculating Surcharge from BRMS Sheet: WaterBillTaxDTO");
        LOGGER.info("End --> " + this.getClass().getSimpleName() + " fetchSurCharge() method ");
        return taxDto;
    }

    @Override
    public void savePortalSurchargeData(WaterBillRequestDTO requestDTO, Long finYearId) {

        WaterPenaltyDto waterPenaltyDto = waterPenaltyService
                .getWaterPenaltyByCCNOByFinId(String.valueOf(requestDTO.getCsIdn()), finYearId, requestDTO.getOrgid());
        if (waterPenaltyDto != null && waterPenaltyDto.getPendingAmount() > 0) {
            double amount = requestDTO.getAmountPaid();
            double pendingSurcharge = waterPenaltyDto.getActualAmount();
            pendingSurcharge -= amount;
            if (pendingSurcharge <= 0) {
                pendingSurcharge = 0;
            }
            amount -= waterPenaltyDto.getActualAmount();
            waterPenaltyDto.setPendingAmount(pendingSurcharge);
            waterPenaltyDto.setLgIpMacUpd(requestDTO.getIpAddress());
            waterPenaltyDto.setUpdatedBy(requestDTO.getUserId());
            waterPenaltyService.updateWaterPenalty(waterPenaltyDto);
            requestDTO.setAmountPaid(amount);
            LOGGER.info("SurCharge Details Updated Successfully");
        }
    }

    public int getMonthFromDate(Date date) {

        int result = -1;
        if (date != null) {
            Calendar cal = Calendar.getInstance();
            cal.setTime(date);
            result = cal.get(Calendar.MONTH) + 1;
        }
        return result;
    }

    @Override
    public List<TbBillMas> getUnpaidBillEntityToDto(List<TbWtBillMasEntity> billGenerated) {
        List<TbBillMas> billMasList = new ArrayList<>(0);
        for (TbWtBillMasEntity billMas : billGenerated) {
            TbBillMas billMasDTO = new TbBillMas();
            List<TbBillDet> billDetailList = new ArrayList<>(0);
            BeanUtils.copyProperties(billMas, billMasDTO);
            for (TbWtBillDetEntity det : billMas.getBillDetEntity()) {
                TbBillDet billDetailsDTO = new TbBillDet();
                BeanUtils.copyProperties(det, billDetailsDTO);
                billDetailList.add(billDetailsDTO);
            }
            billMasDTO.setTbWtBillDet(billDetailList);
            billMasList.add(billMasDTO);
        }
        return billMasList;
    }

    private TbWtBillSchedule createCopyOfBillSchedule(TbWtBillSchedule entity) {
        TbWtBillSchedule flowDto = null;
        List<TbWtBillScheduleDetail> deatilList = new ArrayList<>(0);
        if (entity != null) {
            flowDto = new TbWtBillSchedule();
            BeanUtils.copyProperties(entity, flowDto);
            for (TbWtBillScheduleDetail detail : entity.getBillScheduleDetail()) {
                TbWtBillScheduleDetail dto = new TbWtBillScheduleDetail();
                BeanUtils.copyProperties(detail, dto);
                deatilList.add(dto);
            }
            flowDto.setBillScheduleDetail(deatilList);
        }
        return flowDto;
    }

    public static Date getZeroTimeDate(Date fecha) {
        Date res = fecha;
        Calendar calendar = Calendar.getInstance();

        calendar.setTime(fecha);
        calendar.set(Calendar.HOUR_OF_DAY, 0);
        calendar.set(Calendar.MINUTE, 0);
        calendar.set(Calendar.SECOND, 0);
        calendar.set(Calendar.MILLISECOND, 0);

        res = calendar.getTime();

        return res;
    }

    public List<Integer> findNoOfMonthBillGenerated(List<TbWtBillMasEntity> billList, TbWtBillMasEntity billmas,
            String billFrequency, String meterType, FinancialYear finincialYear, Organisation orgnisation) {
    	LOGGER.info("Begin--> " + this.getClass().getSimpleName() + " findNoOfMonthBillGenerated() method ");
        Integer month = 0;
        Integer finYearStartMonth = 0;
        List<Integer> monthCalculations = new ArrayList<>(0);
        List<Long> finYearList = new ArrayList<Long>();
        
		// this is to clear existing unpaid bill for new financial year if there are
		// gaps in bills generated
		if (Utility.isEnvPrefixAvailable(orgnisation, MainetConstants.ENV_SKDCL)) {
			LOGGER.info("skdcl to clear existing unpaid bill for new financial year if there are");
				if (!CollectionUtils.isEmpty(billList)) {
					billmas = billList.get(billList.size() - 1);
					if (billmas.getBmTodt().compareTo(finincialYear.getFaFromDate()) <= 0) {
						billList.clear();
					}
				}
		}
        if (!CollectionUtils.isEmpty(billList)) {
        	LOGGER.info("in billlist condition 2825");
            billmas = billList.get(billList.size() - 1);
				

            // calculating the no. of months for which bill not generated till current date
            if(billmas.getBmTodt().compareTo(finincialYear.getFaFromDate()) >= 0 && billmas.getBmTodt().compareTo(finincialYear.getFaToDate()) <=0) {
            	LOGGER.info("in billlist condition 2826");
            	if(Utility.compareDate(finincialYear.getFaToDate(), new Date())) {
            		month = monthsBetweenDates(billmas.getBmTodt(), finincialYear.getFaToDate());
            	}else {
            		month = monthsBetweenDates(billmas.getBmTodt(), new Date());
            	}
            	LOGGER.info("in billlist condition 2827 months"+ month);
            }
            else if(Utility.compareDate(finincialYear.getFaToDate(), new Date())) {
            	LOGGER.info("in billlist condition 2828");
            	month = monthsBetweenDates(finincialYear.getFaFromDate(), finincialYear.getFaToDate());
            	month = month+1;
            	LOGGER.info("in billlist condition 2829 months"+ month);
            }else {
            	LOGGER.info("in billlist condition 2830");
            	month = monthsBetweenDates(finincialYear.getFaFromDate(), new Date());
            	month = month+1;
            	LOGGER.info("in billlist condition 2831 months"+ month);
            }
            
        }
        // check whether bills are present if present then check the difference between
        // last bill to date and current date
		if (!CollectionUtils.isEmpty(billList)
				&& !StringUtils.equals(MainetConstants.NewWaterServiceConstants.YEARLY_BILL_FREQUENCY, billFrequency)) {
			LOGGER.info("in billlist condition 2832 billFrequency"+ billFrequency);
            int billToDateMonth = getMonthFromDate(billmas.getBmTodt());
            if (billToDateMonth <= 2) {
                billToDateMonth += 12;
            }
            int differFinToDateMonth = (billToDateMonth - 4);
            
            if(billmas.getBmTodt().compareTo(finincialYear.getFaFromDate()) >= 0 && billmas.getBmTodt().compareTo(finincialYear.getFaToDate()) <=0) {
            	if (differFinToDateMonth >= 0) {
                    finYearStartMonth = differFinToDateMonth + 1;
                }

                if (StringUtils.equals(MainetConstants.NewWaterServiceConstants.BIMONTHLY_BILL_FREQUENCY, billFrequency)) {
                    finYearStartMonth = finYearStartMonth / 2;
                    month = (int) Math.round((double) month / 2);
                }
                if (StringUtils.equals(MainetConstants.NewWaterServiceConstants.QUARTERLY_BILL_FREQUENCY, billFrequency)) {
                    finYearStartMonth = finYearStartMonth / 3;
                    month = (int) Math.round((double) month / 3);
                }
                if (StringUtils.equals(MainetConstants.NewWaterServiceConstants.HALFYEARLY_BILL_FREQUENCY, billFrequency)) {

                    finYearStartMonth = finYearStartMonth / 6;
                    month = (int) Math.round((double) month / 6);
                }
            }
            LOGGER.info("in billlist condition 2833 finYearStartMonth"+ finYearStartMonth);
            LOGGER.info("in billlist condition 2834 month"+ month);

		} else {
			
			LOGGER.info("in billlist condition 2837 billFrequency"+ billFrequency);
			month = 1;
			int currentMonth = 0;
			currentMonth = getMonthFromDate(new Date());

			if (!StringUtils.equals(MainetConstants.NewWaterServiceConstants.YEARLY_BILL_FREQUENCY, billFrequency)
					&& currentMonth <= 3) {
				currentMonth += 12;
			} 
			if (StringUtils.equals("1", billFrequency))
				finYearStartMonth = currentMonth - 4;

			if (StringUtils.equals(MainetConstants.NewWaterServiceConstants.BIMONTHLY_BILL_FREQUENCY, billFrequency))
				finYearStartMonth = (int) Math.floor((double) (currentMonth - 4) / 2);
			if (StringUtils.equals(MainetConstants.NewWaterServiceConstants.QUARTERLY_BILL_FREQUENCY, billFrequency))
				finYearStartMonth = (int) Math.floor((double) (currentMonth - 4) / 3);
			if (StringUtils.equals(MainetConstants.NewWaterServiceConstants.HALFYEARLY_BILL_FREQUENCY, billFrequency)) {
				if (Utility.isEnvPrefixAvailable(orgnisation, MainetConstants.ENV_SKDCL)) {
					// work around without adding schedule configuration for second-half of fin year
					if(MainetConstants.NewWaterServiceConstants.NON_METER.equals(meterType)) {
						try {
							Long currentFinYearId = iFinancialYearService.getFinanceYearId(new Date());
							if(currentFinYearId.equals(finincialYear.getFaYear())){
								month = getMonthFromDate(new Date()) > 3 && getMonthFromDate(new Date()) < 10 ? 1: 2;
							}else {
								month = 2;
							}
						}catch(Exception ex) {
							LOGGER.error("Please add current financial year for getting bill schedule " + ex.getMessage());
						}
					}else {
						month = 1;
					}
				} else {
					month = 1;
					finYearStartMonth = (int) Math.floor((double) (currentMonth - 4) / 6);
				}
			}
			LOGGER.info("in billlist condition 2835 finYearStartMonth"+ finYearStartMonth);
            LOGGER.info("in billlist condition 2836 month"+ month);

		}
        monthCalculations.add(month);
        monthCalculations.add(finYearStartMonth);
    	LOGGER.info("End--> " + this.getClass().getSimpleName() + " findNoOfMonthBillGenerated() method ");
        return monthCalculations;

    }

    @Override
    @Transactional(readOnly = true)
    public List<TbBillMas> getArrearsDeletionBills(Long csIdn, Long finYearId) {
        List<TbWtBillMasEntity> entity = tbWtBillMasJpaRepository.getArrearsDeletionBills(csIdn, finYearId);
        List<TbBillMas> billMasList = new ArrayList<>(0);
        for (TbWtBillMasEntity billMas : entity) {
            TbBillMas billMasDTO = new TbBillMas();
            List<TbBillDet> billDetailList = new ArrayList<>(0);
            BeanUtils.copyProperties(billMas, billMasDTO);
            for (TbWtBillDetEntity det : billMas.getBillDetEntity()) {
                TbBillDet billDetailsDTO = new TbBillDet();
                BeanUtils.copyProperties(det, billDetailsDTO);
                billDetailsDTO.setBdCsmp(BigDecimal.valueOf(Utility.round(det.getBdCurBalTaxamt(), 2)));
                billDetailList.add(billDetailsDTO);
            }
            billMasDTO.setTbWtBillDet(billDetailList);
            billMasList.add(billMasDTO);
        }
        return billMasList;

    }

    // for arrears which not in current financial year
    @Override
    @Transactional(readOnly = true)
    public List<TbBillMas> getArrearsDeletionBillsForNonCurrFinYear(Long csIdn, Long finYearId,String billFrequency, Long orgId,Long billNo) {
    	
    	List<TbWtBillMasEntity> entity = new ArrayList<TbWtBillMasEntity>();
    	if(StringUtils.isNotBlank(billFrequency) && StringUtils.equals(billFrequency, "1")) {
    		if(billNo != null && billNo > 0) {
    			LOGGER.info("logger 1-billNo is " + billNo + "bill frequency is" + billFrequency);
    			 entity = tbWtBillMasJpaRepository.getArrearsDeletionBillsByCsIdnAndBillNo(csIdn, orgId, String.valueOf(billNo));	
    			 LOGGER.info("logger 1-entity"+entity);
    		}
    		else {
    			LOGGER.info("logger 2-billNo is " +billNo+"bill frequency is"+billFrequency);
    			 entity = tbWtBillMasJpaRepository.getArrearsDeletionBillsForMonthly(csIdn, orgId);
    			 LOGGER.info("logger 2-entity"+entity);
    		}		
    	}else {
    		if(billNo != null && billNo > 0) {
    			LOGGER.info("logger 3-billNo is "+billNo+"bill frequency is"+billFrequency);
    			 entity = tbWtBillMasJpaRepository.getArrearsDeletionBillsByCsIdnAndBillNo(csIdn, orgId,  String.valueOf(billNo));
    			LOGGER.info("logger 3-entity"+entity);
   		}else {
   			Object[] ob = null;
   			ob = iFinancialYearService.getFinacialYearByDate(new Date());
   			long currYear = (long)ob[0];
   			LOGGER.info("logger 4-billNo is "+billNo+"bill frequency is"+billFrequency+"curryear"+currYear);
   		 entity = tbWtBillMasJpaRepository.getArrearsDeletionBillsNotinCurrFinYear(csIdn,
	                currYear);
   		 	LOGGER.info("logger 4-entity"+entity);
   		}
    	}
    	List<TbWtBillMasEntity> collect = null;
    	LOGGER.info("logger 5-finYearId"+finYearId);
    	if(finYearId != null){
    		 collect = entity.stream().filter(bill -> bill.getBmYear().equals(finYearId)).collect(Collectors.toList());
    		 LOGGER.info("logger 5-collect"+collect);
    	}
        List<TbBillMas> billMasList = new ArrayList<>(0);
        for (TbWtBillMasEntity billMas : collect) {
        	if(billNo != null) {
        		if(billNo != null && StringUtils.isNotBlank(billMas.getBmNo()) &&  Double.valueOf(billMas.getBmNo()) >= billNo) {
            		  TbBillMas billMasDTO = new TbBillMas();
                      List<TbBillDet> billDetailList = new ArrayList<>(0);
                      BeanUtils.copyProperties(billMas, billMasDTO);
                      for (TbWtBillDetEntity det : billMas.getBillDetEntity()) {
                          TbBillDet billDetailsDTO = new TbBillDet();
                          BeanUtils.copyProperties(det, billDetailsDTO);
                          billDetailsDTO.setBdCsmp(BigDecimal.valueOf(Utility.round(det.getBdCurBalTaxamt(), 2)));
                          billDetailList.add(billDetailsDTO);
                      }
                      billMasDTO.setTbWtBillDet(billDetailList);
                      billMasList.add(billMasDTO);
            	}
        	}else {
          		  TbBillMas billMasDTO = new TbBillMas();
                    List<TbBillDet> billDetailList = new ArrayList<>(0);
                    BeanUtils.copyProperties(billMas, billMasDTO);
                    for (TbWtBillDetEntity det : billMas.getBillDetEntity()) {
                        TbBillDet billDetailsDTO = new TbBillDet();
                        BeanUtils.copyProperties(det, billDetailsDTO);
                        billDetailsDTO.setBdCsmp(BigDecimal.valueOf(Utility.round(det.getBdCurBalTaxamt(), 2)));
                        billDetailList.add(billDetailsDTO);
                    }
                    billMasDTO.setTbWtBillDet(billDetailList);
                    billMasList.add(billMasDTO);
        	}
        }
        return billMasList;

    }

    // to delete arrears and records saved in history table
    @Override
    @Transactional
    public void deleteArrearInDetByBmId(List<TbBillMas> billMasList, String ipAddress, Long empId) {
    	Organisation org = new Organisation();
        for (TbBillMas billMas : billMasList) {
            try {
                TbWtBIllMasHist history = new TbWtBIllMasHist();
                history.sethStatus(MainetConstants.InsertMode.DELETE.getStatus());
                billMas.setLgIpMacUpd(ipAddress);
                billMas.setUpdatedBy(empId);
                billMas.setUpdatedDate(new Date());
                auditService.createHistory(billMas, history);
                List<Object> historyList = new ArrayList<>();
                billMas.getTbWtBillDet().forEach(masDet -> {
                    TbWtBIllDetHist detailsHistory = new TbWtBIllDetHist();
                    BeanUtils.copyProperties(masDet, detailsHistory);
                    detailsHistory.setBmIdno(billMas.getBmIdno());
                    detailsHistory.sethStatus(MainetConstants.InsertMode.DELETE.getStatus());
                    detailsHistory.setLgIpMacUpd(ipAddress);
                    detailsHistory.setUpdatedBy(empId);
                    detailsHistory.setUpdatedDate(new Date());
                    historyList.add(detailsHistory);
                });
                auditService.createHistoryForListObj(historyList);

            } catch (Exception exception) {
                LOGGER.error("Exception occured when calling audit service  ", exception);
            }
            org.setOrgid(billMas.getOrgid());
//            if(Utility.isEnvPrefixAvailable(org, MainetConstants.ENV_ASCL)) {
//            	
//            	List<TbWtBillMasEntity> billList = tbWtBillMasJpaRepository
//    		            .getBillMasByConnectionId(billMas.getCsIdn());
//            	//Removing selected financial year bill and interest on previous bill 
//            	if(billList!= null && billList.size() > 1) {
//            		Map<Long, List<TbWtBillMasEntity>> collect = billList.stream().collect(
//            				Collectors.groupingBy(bill->bill.getBmIdno()));
//            		Long prevBillId = collect.keySet().stream().sorted(Collections.reverseOrder()).
//        			distinct().limit(2).skip(1).findFirst().get();
//            		TbWtBillMasEntity prevBill = collect.get(prevBillId).get(0);
//                	deleteInterestOnPrevBillDetAndCurrBillDet(billMas, prevBill, org);
//            	}
//            } 
            	
            tbWtBillDetJpaRepository.deleteArrearByBmIdFromDet(billMas.getBmIdno());

            tbWtBillMasJpaRepository.deleteArrearByBmIdFromMas(billMas.getBmIdno());
          }
    }

	private void deleteInterestOnPrevBillDetAndCurrBillDet(TbBillMas billMas, TbWtBillMasEntity prevBill, Organisation organisation) {
		Double interestAmt = 0.0;
		Double totalInterest = 0.0;
		Double totalCumIntArrears = 0.0;
		Double oustandingAmount = prevBill.getBmTotalBalAmount();
		prevBill.getBillDetEntity().forEach(billDet->{
			final String taxCode = CommonMasterUtility
	                .getHierarchicalLookUp(billDet.getTaxCategory(), organisation).getLookUpCode();
			if(taxCode.equals(PrefixConstants.TAX_CATEGORY.INTERST)) {
				tbWtBillDetJpaRepository.updatePrevBillDetails(billDet.getBdBilldetid(), interestAmt, organisation.getOrgid());
			}
		});
		Double totalArrearsAmt = prevBill.getBmTotalArrears() - prevBill.getBmToatlInt();
		oustandingAmount = prevBill.getBmTotalOutstanding() -  prevBill.getBmToatlInt();
		tbWtBillMasJpaRepository.updatePrevBillMasInterestValue(prevBill.getBmIdno(), totalArrearsAmt,
				totalInterest, totalCumIntArrears, oustandingAmount, organisation.getOrgid());
	}

	/**
     * To Calculate get Cycle Start and End For Meter Connection
     * 
     * @param schDetails
     * @return List<Date>
     */
    private List<Date> getCycleStartandEndForMeterConnection(final TbWtBillScheduleDetail schDetails) {
        int start = 0;
        int end = 0;
        List<Date> datesRange = new ArrayList<Date>(0);
        start = schDetails.getCnsFromDate().intValue();
        end = schDetails.getCnsToDate().intValue();
        final FinancialYear finYearData = iFinancialYearService.getFinincialYearsById(schDetails.getYearId(),
        		schDetails.getOrgid());
        final String faYearString = Utility.getCompleteFinancialYear(finYearData.getFaFromDate(),
                finYearData.getFaToDate());
        final Date startDate = Utility.dateFromMonth(faYearString, start, MainetConstants.FINYEAR_DATE.FIRST);
        final Date endDate = Utility.dateFromMonth(faYearString, end, MainetConstants.FINYEAR_DATE.LAST);
        datesRange.add(startDate);
        datesRange.add(endDate);
        return datesRange;
    }

    /**
     * To Calculate No. of months between From date and To Date
     * 
     * @param fromDate
     * @param toDate
     * @return
     */
    static int monthsBetween(Date fromDate, Date toDate) {
        Calendar cal = Calendar.getInstance();
        if (fromDate.before(toDate)) {
            cal.setTime(fromDate);
        } else {
            cal.setTime(toDate);
            toDate = fromDate;
        }
        int months = 0;
        while (cal.getTime().before(toDate)) {
            cal.add(Calendar.MONTH, 1);
            months++;
        }
        return months;

    }

    /**
     * To Calculate No. of months between From date and To Date
     * @author cherupelli.srikanth
     * @date 04-Feb-2020
     * @param fromDate
     * @param toDate
     * @return
     */
    static int monthsBetweenDates(Date fromDate, Date toDate) {
        Calendar startCalendar = Calendar.getInstance();
        startCalendar.setTime(fromDate);
        Calendar endCalendar = Calendar.getInstance();
        endCalendar.setTime(toDate);

        int diffYear = endCalendar.get(Calendar.YEAR) - startCalendar.get(Calendar.YEAR);
        int diffMonth = diffYear * 12 + endCalendar.get(Calendar.MONTH) - startCalendar.get(Calendar.MONTH);
        return diffMonth;
    }

    /**
     * To calculate water bill generation log
     * @param errorListMap
     * @param waterDTO
     * @param count
     * @param size
     * @param totalConnections
     * @param timeTaken
     */
    private void setWaterBillGenerationMap(final Map<Long, WaterBillGenErrorDTO> errorListMap, TbCsmrInfoDTO waterDTO,
            AtomicLong size, int totalConnections, long timeTaken,WaterBillGenerationMap flowDto) {

        BillGenErrorMapDTO billGenErrorMapDTO = null;
        if (!errorListMap.isEmpty() && errorListMap.containsKey(waterDTO.getCsIdn())) {
            WaterBillGenErrorDTO errorDto = errorListMap.get(waterDTO.getCsIdn());
            billGenErrorMapDTO = new BillGenErrorMapDTO();
            billGenErrorMapDTO.setErrDate(errorDto.getErrDate());
            billGenErrorMapDTO.setErrMsg(errorDto.getErrMsg());
            billGenErrorMapDTO.setOrgId(errorDto.getOrgId());
            billGenErrorMapDTO.setRefId(errorDto.getCsIdn());
            billGenErrorMapDTO.setRefnumber(errorDto.getConnumber());
        }
        if (!errorListMap.isEmpty() && errorListMap.containsKey(waterDTO.getCsIdn()))
            flowDto.getErrorListMap().putIfAbsent(waterDTO.getCsIdn(), billGenErrorMapDTO);
        flowDto.setNoOfBillsForGeneration((long) totalConnections);
        // flowDto.setNoOfBillsSelectedForGeneration(size.longValue());
        flowDto.setNoOfBillsGeneratedSuccessfull(
                (totalConnections - size.longValue()) - ((long) flowDto.getErrorListMap().size()));
        flowDto.setNoOfBillsGotErrors((long) flowDto.getErrorListMap().size());
        flowDto.setApproximatelyTakenTimeForBillGeneration((long) (size.longValue() * (timeTaken * 0.001)) * size.longValue());
        flowDto.setNoOfBillsPending(size.longValue());
        // flowDto.setNoOfBillsGeneratedSuccessfull(totalConnections - size.longValue());
        flowDto.setOrgId(waterDTO.getOrgId());
		ApplicationSession.getInstance().getWaterBillGenerationMapOrgId().put(waterDTO.getOrgId(), flowDto);
    }
    
    @Override
    public List<Long> getFinYearListFromLastBillGenDate(List<TbWtBillMasEntity> billList, TbWtBillMasEntity billmas,Long finYearId){
    	LOGGER.info("Begin--> " + this.getClass().getSimpleName() + " getFinYearListFromLastBillGenDate() method ");
    	List<Long> finYearList = new ArrayList<Long>();
    	if(CollectionUtils.isNotEmpty(billList)) {
    		billmas = billList.get(billList.size() - 1);
    		//Long financeYearId = iFinancialYearService.getFinanceYearId(billmas.getBmTodt());
    		List<FinancialYear> financeYearListFromGivenDate = iFinancialYearService.getFinanceYearListFromGivenDate(billmas.getOrgid(), billmas.getBmYear(), new Date());
    		if (!financeYearListFromGivenDate.isEmpty()) {
                finYearList = new ArrayList<>();
                for (FinancialYear financialYearEach : financeYearListFromGivenDate) {
                	if(financialYearEach.getFaToDate().compareTo(billmas.getBmTodt()) != 0) {
                		//Long finYear = iFinancialYearService.getFinanceYearId(financialYearEach.getFaFromDate());
                        finYearList.add(financialYearEach.getFaYear());
                	}
                    
                }
            }
    	}else {
    		//Long finYear = iFinancialYearService.getFinanceYearId(new Date());
    		finYearList.add(finYearId);
    	}
    	LOGGER.info("End--> " + this.getClass().getSimpleName() + " getFinYearListFromLastBillGenDate() method ");
    	return finYearList;    	
    }
    
    private boolean excludeLastBillAmount(TbBillMas lastBillMas, Organisation organisation, Date dueDateCrossed) {
    	Date finalDueDate = lastBillMas.getBmDuedate();
    	boolean chargeApplFlag = false;
    	boolean iterationFlag = true;
    	while(iterationFlag) {
    		List<HolidayMasterDto> dueDateHoliday = holidayMasterService.getHolidayDates(finalDueDate, organisation.getOrgid());
    		if(CollectionUtils.isNotEmpty(dueDateHoliday)) {
    			Timestamp finalDusDateStamp =new Timestamp(finalDueDate.getTime());
    			  Date finalBillDSueDate = new Date(finalDusDateStamp.getTime()); 
        		LocalDate convertDueDateToLocalDate = finalBillDSueDate.toInstant()
    					.atZone(ZoneId.systemDefault()).toLocalDate();
    			Date afterAddingDaysToDueDate = Date.from(
    					convertDueDateToLocalDate.plusDays(Long.valueOf(1)).atStartOfDay(ZoneId.systemDefault()).toInstant());
    			finalDueDate = afterAddingDaysToDueDate;
        	}else {
        		iterationFlag = false;
        	}
    	}
    	if(!(Utility.compareDate(finalDueDate, dueDateCrossed) && !Utility.comapreDates(finalDueDate, dueDateCrossed))) {
    		chargeApplFlag = true;
    	}
    	return chargeApplFlag;
    }
    
    private Map<Long, List<TbWtBillSchedule>> getNonMeterBllScheduleByOrgid(Organisation organisation){
    	 Map<Long, List<TbWtBillSchedule>> nonMeterBillSchedMap = new HashMap<Long, List<TbWtBillSchedule>>();
        List<TbWtBillSchedule> nonMeterBillScheduleList = tbWtBillScheduleService.getBillScheduleByOrgId(organisation.getOrgid(), MainetConstants.NewWaterServiceConstants.NON_METER);
        nonMeterBillScheduleList.forEach(nonMeter ->{
        	List<TbWtBillSchedule> nonMeterList = new ArrayList<TbWtBillSchedule>();
        	nonMeterList.add(nonMeter);
        	nonMeterBillSchedMap.put(nonMeter.getCnsYearid(), nonMeterList);
        });
         
        return nonMeterBillSchedMap;
    }
    
    private Map<Long, List<TbWtBillSchedule>> getMeterBllScheduleByOrgid(Organisation organisation){
   	 Map<Long, List<TbWtBillSchedule>> meterBillSchedMap = new HashMap<Long, List<TbWtBillSchedule>>();
       List<TbWtBillSchedule> meterBillScheduleList = tbWtBillScheduleService.getBillScheduleByOrgId(organisation.getOrgid(), MainetConstants.NewWaterServiceConstants.METER);
       meterBillScheduleList.forEach(nonMeter ->{
       	List<TbWtBillSchedule> nonMeterList = new ArrayList<TbWtBillSchedule>();
       	nonMeterList.add(nonMeter);
       	meterBillSchedMap.put(nonMeter.getCnsYearid(), nonMeterList);
       });
        
       return meterBillSchedMap;
   }
    
    private Map<Long, FinancialYear> getFinYearList(List<Long> finYearIdList){
    	Map<Long, FinancialYear> finYearMap = new HashMap<Long, FinancialYear>();
    	 List<FinancialYear> finYearByFinIdList = iFinancialYearService.getFinYearByFinIdList(finYearIdList);
    	 finYearByFinIdList.forEach(finYear ->{
    		 finYearMap.put(finYear.getFaYear(), finYear);
    		 
    	 });
    	 
    	 return finYearMap;
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<TbBillMas> getArrearsDeletionBillsByGreaterAndEqualfinId(Long csIdn, Long finYearId, Long orgId) {
    	
    	List<TbWtBillMasEntity> entity = new ArrayList<TbWtBillMasEntity>();
    		if(finYearId != null && finYearId > 0) {
    			 entity = tbWtBillMasJpaRepository.getArrearsDeletionBillsByGreaterAndEqualfinId(csIdn, orgId, finYearId);
    			
    		}
    		else {
    			 entity = tbWtBillMasJpaRepository.getArrearsDeletionBillsForMonthly(csIdn, orgId);
    		}
    			
    	
        List<TbBillMas> billMasList = new ArrayList<>(0);
        for (TbWtBillMasEntity billMas : entity) {
        	if(finYearId != null) {
        		if(finYearId != null &&   billMas.getBmYear() >= finYearId) {
            		  TbBillMas billMasDTO = new TbBillMas();
                      List<TbBillDet> billDetailList = new ArrayList<>(0);
                      BeanUtils.copyProperties(billMas, billMasDTO);
                      for (TbWtBillDetEntity det : billMas.getBillDetEntity()) {
                          TbBillDet billDetailsDTO = new TbBillDet();
                          BeanUtils.copyProperties(det, billDetailsDTO);
                          billDetailsDTO.setBdCsmp(BigDecimal.valueOf(Utility.round(det.getBdCurBalTaxamt(), 2)));
                          billDetailList.add(billDetailsDTO);
                      }
                      billMasDTO.setTbWtBillDet(billDetailList);
                      billMasList.add(billMasDTO);
            	}
        	}else {
          		  TbBillMas billMasDTO = new TbBillMas();
                    List<TbBillDet> billDetailList = new ArrayList<>(0);
                    BeanUtils.copyProperties(billMas, billMasDTO);
                    for (TbWtBillDetEntity det : billMas.getBillDetEntity()) {
                        TbBillDet billDetailsDTO = new TbBillDet();
                        BeanUtils.copyProperties(det, billDetailsDTO);
                        billDetailsDTO.setBdCsmp(BigDecimal.valueOf(Utility.round(det.getBdCurBalTaxamt(), 2)));
                        billDetailList.add(billDetailsDTO);
                    }
                    billMasDTO.setTbWtBillDet(billDetailList);
                    billMasList.add(billMasDTO);
        	}
        }
        return billMasList;

	}

	@Override
	@Transactional
	public List<WaterPenaltyDto> calculateSurcharge(Organisation organisation, Long deptId, List<TbBillMas> billMasList,
			TbTaxMas taxMas, Long finYearId, TbCsmrInfoDTO csmrInfoDto, String ipAddress, Long userId,
			String billGenFlag, Date manualReceiptDate, List<WaterPenaltyDto> surchargeList) {
		List<WaterPenaltyDto> surChargesList = new ArrayList<>();

		WaterBillTaxDTO surchargeTaxDto = null;
		Date dueDateCrossed = new Date();
//		if (manualReceiptDate != null) {
//			dueDateCrossed = manualReceiptDate;
//		}
		double totalArrear = 0;
		TbBillMas billMaster = null;
		TbBillMas previousBillMas = null;
		Long bmIdNo = 0L;
		List<LookUp> lookUpList = CommonMasterUtility.lookUpListByPrefix("ICM", organisation.getOrgid());
		List<LookUp> SurchargeCalculation = lookUpList.stream().filter(lookUp -> lookUp.getOtherField().equals("Y"))
				.collect(Collectors.toList());
		// fetch bill wise surchage and return into a list
		if (CollectionUtils.isNotEmpty(billMasList)) {
			surchargeList = waterPenaltyService.getWaterPenaltyByBmNoIds(billMasList, organisation.getOrgid());
			LOGGER.info("Checking Surcharge Calculated aginst particular Bill");
		}
		if (CollectionUtils.isNotEmpty(billMasList)) {
			for (TbBillMas billMas : billMasList) {
				WaterPenaltyDto waterSurCharge = null;
				int daysBetweenDates = 0;

				List<WaterPenaltyDto> collect = surchargeList.stream()
						.filter(detail -> detail.getBmIdNo().equals(billMas.getBmIdno())).collect(Collectors.toList());
				if (CollectionUtils.isNotEmpty(collect)) {
					WaterPenaltyDto surchargeDto = new WaterPenaltyDto();
					BeanUtils.copyProperties(collect.get(0), surchargeDto);
					surchargeDto.setArrearPenalty(surchargeDto.getPendingAmount());
					boolean isUpdatePenaltyTableFlag = false;
					Date surchargeFromDate = null;
					if (Utility.compareDate(billMas.getBmDuedate(), dueDateCrossed)
							&& !Utility.comapreDates(billMas.getBmDuedate(), dueDateCrossed)
							&& (((manualReceiptDate != null && (((surchargeDto.getBillGenAmount() != null))
									|| (Utility.compareDate(surchargeDto.getSurchargeToDate(), manualReceiptDate)))
									|| (manualReceiptDate != null
											&& (Utility.compareDate(manualReceiptDate,
													surchargeDto.getSurchargeToDate()))
											&& surchargeDto.getBillGenAmount() != null)))
									|| (manualReceiptDate == null))) {
						totalArrear = totalArrear + billMas.getBmTotalBalAmount();
						if (billMas.getBmTotalBalAmount() > 0) {
							// daysBetweenDates =
							// surchargeDayMonthYearWiseCalculations(dueDateCrossed,SurchargeCalculation,
							// daysBetweenDates, surchargeDto.getSurchargeToDate());

//							daysBetweenDates = monthsBetweenDates(
//
//									manualReceiptDate != null && ((billMas.getUpdatedDate() == null
//											&& surchargeDto.getUpdatedDate() != null
//											&& Utility.comapreDates(manualReceiptDate, surchargeDto.getUpdatedDate()))
//											|| (billMas.getUpdatedDate() != null && Utility
//													.comapreDates(billMas.getUpdatedDate(), manualReceiptDate)))
//															? billMasList.get(billMasList.size() - 1).getBmBilldt()
//															: billMas.getBmDuedate(),
//									dueDateCrossed) + 1;
							surchargeFromDate = manualReceiptDate != null
									&& (billMas.getUpdatedDate() == null && surchargeDto.getUpdatedDate() != null
									&& Utility.comapreDates(manualReceiptDate, surchargeDto.getUpdatedDate()))
										? surchargeDto.getUpdatedDate() 
										: (billMas.getUpdatedDate() != null && Utility.comapreDates(billMas.getUpdatedDate(), manualReceiptDate))
									? billMas.getUpdatedDate()
									: billMas.getBmDuedate();
//									|| (billMas.getUpdatedDate() != null && Utility
//											.comapreDates(billMas.getUpdatedDate(), manualReceiptDate)))
//													? billMas.getUpdatedDate() != null ? billMas.getUpdatedDate
//													: billMas.getBmDuedate();
													
							daysBetweenDates = monthsBetweenDates(surchargeFromDate, dueDateCrossed) + 1;

							/*
							 * daysBetweenDates = monthsBetweenDates(manualReceiptDate != null &&
							 * ((billMas.getUpdatedDate() == null && surchargeDto.getUpdatedDate() != null
							 * && Utility.comapreDates(manualReceiptDate, surchargeDto.getUpdatedDate())) ||
							 * (billMas.getUpdatedDate() != null && Utility
							 * .comapreDates(billMas.getUpdatedDate(), manualReceiptDate))) ?
							 * billMasList.get(billMasList.size() - 1).getBmBilldt() :
							 * billMas.getBmDuedate(), dueDateCrossed) + 1;
							 */
							
						}
						previousBillMas = billMaster;
						billMaster = billMas;
					}
					if (billMaster != null && excludeLastBillAmount(billMaster, organisation, dueDateCrossed)) {
						totalArrear = totalArrear - billMaster.getBmTotalBalAmount();
						if (previousBillMas != null) {
							billMaster = previousBillMas;
							// lastBillSurBillId = billMaster.getBmIdno();
						}
					}
					if (daysBetweenDates > 0 && billMas.getBmTotalBalAmount() > 0) {
						surchargeTaxDto = fetchSurCharge(organisation, deptId, billMas.getBmTotalBalAmount(), taxMas,
								csmrInfoDto, daysBetweenDates);
						if (surchargeTaxDto != null) {
							surchargeDto.setActualArrrearAmount(billMas.getBmTotalBalAmount());

							if (surchargeDto.getUpdatedDate() == null) {
								isUpdatePenaltyTableFlag = true;
								if(surchargeDto.getTaxId()!=surchargeTaxDto.getTaxId()) {
									double pendingAmount = surchargeDto.getPendingAmount();
									surchargeDto.setActualAmount(
											surchargeTaxDto.getTaxAmount() + surchargeDto.getActualAmount());
									surchargeDto.setPendingAmount(
											surchargeTaxDto.getTaxAmount() + pendingAmount);
									surchargeDto.setCurrentPenalty(
											surchargeTaxDto.getTaxAmount() + pendingAmount);
								}else {
									surchargeDto.setActualAmount(surchargeTaxDto.getTaxAmount());
									surchargeDto.setPendingAmount(surchargeTaxDto.getTaxAmount());
									surchargeDto.setCurrentPenalty(surchargeTaxDto.getTaxAmount());
								}
							} else {
								if (monthsBetweenDates(surchargeDto.getUpdatedDate(), new Date()) > 0) {
									isUpdatePenaltyTableFlag = true;

									if (manualReceiptDate != null) {
										double pendingAmount = surchargeDto.getPendingAmount();
										surchargeDto.setActualAmount(
												surchargeTaxDto.getTaxAmount() + surchargeDto.getActualAmount());
										surchargeDto.setPendingAmount(
												surchargeTaxDto.getTaxAmount() + pendingAmount);
										surchargeDto.setCurrentPenalty(
												surchargeTaxDto.getTaxAmount() + pendingAmount);
									} else {
										surchargeDto.setActualAmount(surchargeTaxDto.getTaxAmount());
										surchargeDto.setPendingAmount(surchargeTaxDto.getTaxAmount());
										surchargeDto.setCurrentPenalty(surchargeTaxDto.getTaxAmount());
									}
								} else {
									surchargeDto.setCurrentPenalty(surchargeDto.getPendingAmount());
								}
							}

							/*
							 * if (manualReceiptDate != null) {
							 * surchargeDto.setActualAmount(surchargeTaxDto.getTaxAmount());
							 * surchargeDto.setPendingAmount(surchargeTaxDto.getTaxAmount()); } else {
							 * surchargeDto.setActualAmount( surchargeDto.getActualAmount() +
							 * surchargeTaxDto.getTaxAmount()); surchargeDto.setPendingAmount(
							 * surchargeDto.getPendingAmount() + surchargeTaxDto.getTaxAmount()); }
							 * 
							 * if (StringUtils.isNotBlank(billGenFlag) && StringUtils.equals(billGenFlag,
							 * MainetConstants.FlagY)) { if (surchargeDto.getBillGenAmount() != null) {
							 * surchargeDto.setBillGenAmount(surchargeDto.getBillGenAmount() +
							 * surchargeTaxDto.getTaxAmount());
							 * surchargeDto.setCurrBmIdNo(billMas.getBmIdno()); } else {
							 * surchargeDto.setBillGenAmount(surchargeTaxDto.getTaxAmount()); } }
							 */
							// Here setting the data to update in penalty table
							surchargeDto.setBmIdNo(billMas.getBmIdno());
							surchargeDto.setUpdatedBy(userId);
							surchargeDto.setUpdatedDate(new Date());
							surchargeDto.setLgIpMacUpd(ipAddress);
							
							surchargeDto.setSurchargeFromDate(surchargeFromDate);
							//surchargeDto.setSurchargeFromDate(surchargeDto.getSurchargeToDate());
							surchargeDto.setSurchargeToDate(dueDateCrossed);

							if (isUpdatePenaltyTableFlag && StringUtils.isNotBlank(billGenFlag)
									&& StringUtils.equals(billGenFlag, MainetConstants.FlagY)) {

								if (surchargeDto.getBillGenAmount() != null) {
									surchargeDto.setBillGenAmount(
											surchargeDto.getBillGenAmount() + surchargeTaxDto.getTaxAmount());
									surchargeDto.setCurrBmIdNo(billMas.getBmIdno());
								} else {
									surchargeDto.setBillGenAmount(surchargeTaxDto.getTaxAmount());
								}
								waterPenaltyService.updateWaterPenalty(surchargeDto);
								LOGGER.info("SurCharge Details Updated Successfully");
							}
						}
					}
					if (surchargeDto.getPendingAmount() > 0)
						surChargesList.add(surchargeDto);
				} else {
					if (Utility.compareDate(billMas.getBmDuedate(), dueDateCrossed)
							&& !Utility.comapreDates(billMas.getBmDuedate(), dueDateCrossed)) {
						bmIdNo = billMas.getBmIdno();
						if (billMas.getBmTotalBalAmount() > 0) {
							// tax should be calculated after due date to current date.
							// daysBetweenDates = Utility.getDaysBetDates(billMas.getBmDuedate(),
							// dueDateCrossed);
							// noOfMonthsSurcharge = noOfMonthsSurcharge + monthsBetweenDates;
							/*
							 * daysBetweenDates = surchargeDayMonthYearWiseCalculations(dueDateCrossed,
							 * SurchargeCalculation, daysBetweenDates, billMas.getBmDuedate());
							 */
							daysBetweenDates = monthsBetweenDates(
									manualReceiptDate != null && billMas.getUpdatedDate() != null
											&& Utility.comapreDates(billMas.getUpdatedDate(), manualReceiptDate)
													? billMas.getUpdatedDate()
													: billMas.getBmDuedate(),
									dueDateCrossed) + 1;
							previousBillMas = billMaster;
							billMaster = billMas;
						}
					}
					if (billMaster != null && excludeLastBillAmount(billMaster, organisation, dueDateCrossed)) {
						totalArrear = totalArrear - billMaster.getBmTotalBalAmount();
						if (previousBillMas != null) {
							billMaster = previousBillMas;
							bmIdNo = billMaster.getBmIdno();
						}
					}
					if (daysBetweenDates > 0 && billMas.getBmTotalBalAmount() > 0) {
						// Here fetching charges from BRMS Sheet and calculating
						LOGGER.info("Starts Surcharge Calculation from BRMS Sheet");
						surchargeTaxDto = fetchSurCharge(organisation, deptId, billMas.getBmTotalBalAmount(), taxMas,
								csmrInfoDto, daysBetweenDates);
						// Here setting the data to save in penalty table
						if (surchargeTaxDto != null) {
							waterSurCharge = new WaterPenaltyDto();
							waterSurCharge.setConnNo(String.valueOf(csmrInfoDto.getCsIdn()));
							waterSurCharge.setBmIdNo(bmIdNo);
							waterSurCharge.setCreateddate(new Date());
							waterSurCharge.setCretedBy(userId);
							waterSurCharge.setLgIpmac(ipAddress);
							waterSurCharge.setOrgId(organisation.getOrgid());
							waterSurCharge.setTaxId(surchargeTaxDto.getTaxId());
							waterSurCharge.setActualAmount(surchargeTaxDto.getTaxAmount());
							waterSurCharge.setActualArrrearAmount(totalArrear);
							waterSurCharge.setCurrentPenalty(surchargeTaxDto.getTaxAmount());
							waterSurCharge.setPendingAmount(surchargeTaxDto.getTaxAmount());
							waterSurCharge.setArrearPenalty(0);
							if (billMaster != null) {
								if (Utility.isEnvPrefixAvailable(organisation, "SKDCL")) {
									waterSurCharge.setSurchargeFromDate(billMaster.getBmDuedate());
									waterSurCharge.setSurchargeToDate(dueDateCrossed);
								} else {
									waterSurCharge.setSurchargeFromDate(billMasList.get(0).getBmFromdt());
									waterSurCharge.setSurchargeToDate(billMaster.getBmTodt());
								}
								waterSurCharge.setFinYearId(billMaster.getBmYear());
							} else {
								waterSurCharge.setFinYearId(finYearId);
							}

							if (StringUtils.isNotBlank(billGenFlag)
									&& StringUtils.equals(billGenFlag, MainetConstants.FlagY)) {
								waterSurCharge.setBillGenAmount(surchargeTaxDto.getTaxAmount());
								waterSurCharge.setCurrBmIdNo(billMasList.get(billMasList.size() - 1).getBmIdno());
								// insert into penalty table
								waterPenaltyService.saveWaterPenalty(waterSurCharge);
								LOGGER.info("SurCharge Details Saved Successfully");
							}

							surChargesList.add(waterSurCharge);
						}

					}

				}
			}
		}

		return surChargesList;
	}

	/**
	 * @param dueDateCrossed
	 * @param SurchargeCalculation
	 * @param daysBetweenDates
	 * @param surchargeDto
	 * @return
	 */
	private int surchargeDayMonthYearWiseCalculations(Date dueDateCrossed, List<LookUp> SurchargeCalculation,
			int daysBetweenDates, Date fromDate) {
		// Days Wise, Month Wise, Year Wise Calculation
		if (CollectionUtils.isNotEmpty(SurchargeCalculation)) {
			if (SurchargeCalculation.get(0).getLookUpCode().equals("D")) {
				daysBetweenDates = Utility.getDaysBetDates(fromDate, dueDateCrossed);
			} else if (SurchargeCalculation.get(0).getLookUpCode().equals("M")) {
				daysBetweenDates = monthsBetweenDates(fromDate, dueDateCrossed) + 1;
			} else if (SurchargeCalculation.get(0).getLookUpCode().equals("Y")) {
				daysBetweenDates = Utility.getYearsBetweenDates(fromDate, dueDateCrossed);
			}
		} else {
			LOGGER.info("ICM Prefix Not Configured For Surcharge Calculation Method");
		}
		return daysBetweenDates;
	}
	
	private boolean checkDaysExtendedCovidActive(Organisation organisation) {

		boolean covidActiveFlag = false;
		long lookUpId = 0;
		try {
			lookUpId = CommonMasterUtility.lookUpIdByLookUpCodeAndPrefix("CWS", "SCW", organisation.getOrgid());
		} catch (Exception exception) {
			
		}

		if (lookUpId > 0) {
			covidActiveFlag = true;
		}
		return covidActiveFlag;

	}
	
	private double arrearAmountIfCovidActive(Organisation organisation, TbBillMas billMas, Long finYearId,Date manualReceiptDate) {
		LOGGER.info("arrearAmountIfCovidActive method starts");
		Date currentDate = new Date();
		if(manualReceiptDate != null) {
			currentDate = manualReceiptDate;
		}
		FinancialYear currentFinYear = iFinancialYearService.getFinincialYearsById(finYearId, organisation.getOrgid());
		
		  Timestamp currFinYearTimeStamp =new Timestamp(currentFinYear.getFaFromDate().getTime());
		  Date currentFinYearDate = new Date(currFinYearTimeStamp.getTime()); 
		  
		LocalDate convertFinFromDateToLocalDate = currentFinYearDate.toInstant()
				.atZone(ZoneId.systemDefault()).toLocalDate();

		currentFinYear.getFaToDate().getTime();
		Date afterSubMonths = Date
				.from(convertFinFromDateToLocalDate.minusMonths(5).atStartOfDay(ZoneId.systemDefault()).toInstant());
		FinancialYear previousFinYear = tbFinancialyearService.getFinanciaYearByDate(afterSubMonths);
		LOGGER.error("previous fin year id" +" " + previousFinYear.getFaYear());

		LookUp covidActivePrefix = CommonMasterUtility.getValueFromPrefixLookUp("CWS", "SCW", organisation);
		LOGGER.info("arrearAmountIfCovidActive method ---> prefix CWS starts");
		if (billMas!= null && billMas.getBmTotalBalAmount() > 0 && covidActivePrefix != null) {
			Timestamp prevFinYearTimeStamp =new Timestamp(previousFinYear.getFaToDate().getTime());
			  Date prevFinYearDate = new Date(prevFinYearTimeStamp.getTime()); 
			LocalDate convertFinToDateToLocalDate = prevFinYearDate.toInstant().atZone(ZoneId.systemDefault())
					.toLocalDate();
			Date afterAddingDaysToFinToDate = Date
					.from(convertFinToDateToLocalDate.plusDays(Long.valueOf(covidActivePrefix.getOtherField()))
							.atStartOfDay(ZoneId.systemDefault()).toInstant());
			Date billDueDate = billMas.getBmFromdt();
			if (Utility.compareDate(billDueDate, afterAddingDaysToFinToDate)
					|| Utility.comapreDates(billDueDate, afterAddingDaysToFinToDate)) {
				if (billMas.getBmYear().equals(currentFinYear.getFaYear())) {
					LOGGER.info("arrearAmountIfCovidActive method ---> surcharge not applicable-" + billMas.getBmIdno());
					return 0;
				}
				LOGGER.info("arrearAmountIfCovidActive method ---> surcharge applicable-" + billMas.getBmIdno());
			}
			LOGGER.info("arrearAmountIfCovidActive method ---> prefix CWS ends");

		}
		LOGGER.info("arrearAmountIfCovidActive method ends");
		return billMas.getBmTotalBalAmount();
	}
	
	public void customMeteredBillGeneration(final Organisation organisation, final Map<Long, WaterBillGenErrorDTO> errorListMap,
			final List<TbCsmrInfoDTO> entitylist, final String remarks, final Long empId, final int langId,
			String ipAddress, final List<Long> billNoList, WaterRateMaster rateMasterInit,
			WaterTaxCalculation taxCalculationInit, NoOfDays noOfDaysInit, final Map<Long, Boolean> billPresent,
			final Map<Long, BillTaxDTO> meterReadingMap, final Map<Long, Long> gapDays, Long finYearId,
			final Map<Long, SMSAndEmailDTO> smsEmailMap, final Long deptId, final LookUp chargeApplicableAt,
			final List<TbTaxMas> taxListMeter, final List<TbTaxMas> taxListNonMeter,
			Map<Long, List<TbBillMas>> notPaidBills, final Map<Long, TbWtExcessAmt> excessAmountData,
			final Map<Long, DemandNotice> demandNotice, Map<Long, List<TbWtBillSchedule>> nonMeterBllScheduleByOrgid,
			Map<Long, List<TbWtBillSchedule>> meterBllScheduleByOrgid, Map<Long, FinancialYear> finYearMap,
			final LookUp meterType, final List<TbTaxMas> taxesMasterForReceipt, Long surchargeTaxId,
			final Map<Long, List<AdjustmentMasterEntity>> adjustmentEntry, final String billingMethodDesc,
			Set<Long> connectionids, WaterBillGenerationMap flowDto, List<Long> billIdListForVoucherPosting,
			AtomicLong selectedCount, TbCsmrInfoDTO waterDTO) {
		
		LOGGER.info("Begin--> " + this.getClass().getSimpleName() + " customMeteredBillGeneration() method & Connection No. : "
				+ waterDTO.getCsCcn());
		long startTime = System.currentTimeMillis();
		List<TbBillMas> currentnotPaidBills = new ArrayList<>();
		LOGGER.info("Custom Bill Generation started for Connection" + waterDTO.getCsCcn());
		LOGGER.info("Custom Bill Generation started for Connection Count" + selectedCount);
		List<TbWtBillMasEntity> newbillsGenerated = new ArrayList<>(0);
		final WaterBillGenErrorDTO errorDto = new WaterBillGenErrorDTO();
		
		try {
			 Map<Long, WaterRateMaster> waterRateMap = new LinkedHashMap<>(0);
			 Map<Long, WaterTaxCalculation> taxCalculationMap = new LinkedHashMap<>(0);
			 
			 TbWtExcessAmt excessAmount = null;
			 DemandNotice demandNoticeCharge = null;
			 AtomicDouble interestValue = new AtomicDouble(0);
			 BillTaxDTO interestTaxDto = null;
			 Long interestTaxId = 0l;
			 List<TbTaxMas> taxList = taxListMeter;
			 TbWtBillMasEntity billmas = null;
			 List<TbWtBillMasEntity> calculatedBills = null;
			 List<TbWtBillMasEntity> billList = tbWtBillMasJpaRepository.getBillMasByConnectionId(waterDTO.getCsIdn());
			 List<TbWtBillMasEntity> billGenerated = new ArrayList<>(0);

			 List<Long> finYearListFromLastBillGenDate = getFinYearListFromLastBillGenDate(billList, billmas,finYearId);

			List<TbMrdataEntity> meterReadingDataForBillGen = meterReadingRepository.meterReadingDataForBillGen(Arrays.asList(waterDTO.getCsIdn()),
					organisation.getOrgid());
			if(!CollectionUtils.isEmpty(meterReadingDataForBillGen)) {
				Long cutOffId = CommonMasterUtility.getValueFromPrefixLookUp(PrefixConstants.WATERMODULEPREFIX.CT,
						PrefixConstants.WATERMODULEPREFIX.WTP, organisation).getLookUpId();
				Optional<TbMrdataEntity> isCutOffOrRestorationEntry = meterReadingDataForBillGen.stream().filter(reading-> reading.getMrdCpdIdWtp().equals(cutOffId)).findAny();

				//Regular Billing
				if(isCutOffOrRestorationEntry!=null && !isCutOffOrRestorationEntry.isPresent()) {
					BillTaxDTO meter = meterReadingMap.get(waterDTO.getCsIdn());
					
			        if (meter != null) {
			        	LOGGER.info("Meter is not null");

				        Map<Long, TbTaxMas> taxes = new HashMap<>(0);
				        List<BillTaxDTO> taxAmountList1 = new ArrayList<>(0);

			        	calculatedBills = calculateTaxesAndGenerateBill(taxList, waterDTO, organisation, rateMasterInit, meter, errorDto, errorListMap,
			        			meterType, billingMethodDesc, chargeApplicableAt, null, waterRateMap, taxCalculationInit,
				        		taxCalculationMap, interestTaxId, interestTaxDto, excessAmount, excessAmountData, demandNotice,
				        		demandNoticeCharge, taxAmountList1, finYearListFromLastBillGenDate, billGenerated, currentnotPaidBills,
				        		taxes, langId, interestValue, smsEmailMap, notPaidBills, 0, finYearListFromLastBillGenDate.
		                        get(finYearListFromLastBillGenDate.size()-1) , connectionids,
				        		adjustmentEntry, 0, remarks, ipAddress, empId);
			       
			        } else {
			        	LOGGER.info("Meter is null");
			            final String errorMsg = ApplicationSession.getInstance()
			                    .getMessage("water.bill.nonMeterDays");
			            setErrorMap(errorListMap, errorDto, waterDTO, errorMsg);
			        }
			        
			    }else {
			    	LOGGER.error("Water connection is cutoff");
	                throw new FrameworkException("Water connection is cutoff");
			    }
			    newbillsGenerated.addAll(calculatedBills);
			   
			}
			
		}catch(Exception e) {
			LOGGER.error("Error in water bill generation of connection number "+ waterDTO.getCsCcn()+" of method customMeteredBillGeneration: \n "+ e.getMessage());
		    final String errorMsg = ApplicationSession.getInstance().getMessage("water.bill.error");
		    setErrorMap(errorListMap, errorDto, waterDTO, errorMsg);
		    LOGGER.info("Error ---------------> "+e);
		}
		
		calculatePenaltiesIncurredOnPrevBills(newbillsGenerated, currentnotPaidBills, taxListNonMeter, organisation,
				selectedCount, errorListMap, waterDTO, entitylist, flowDto, smsEmailMap, langId, empId, ipAddress, billNoList,
				billIdListForVoucherPosting, finYearId, deptId, startTime, adjustmentEntry);

	}
	
	
	 private List<TbWtBillMasEntity> calculateTaxesAndGenerateBill(List<TbTaxMas> taxList, TbCsmrInfoDTO waterDTO, Organisation organisation,
				WaterRateMaster rateMasterInit, BillTaxDTO meter, WaterBillGenErrorDTO errorDto,
				Map<Long, WaterBillGenErrorDTO> errorListMap, LookUp meterType, String billingMethodDesc,
				LookUp chargeApplicableAt, List<TbWtBillSchedule> billSchedule, Map<Long, WaterRateMaster> waterRateMap,
				WaterTaxCalculation taxCalculationInit, Map<Long, WaterTaxCalculation> taxCalculationMap, Long interestTaxId, BillTaxDTO interestTaxDto,
				TbWtExcessAmt excessAmount, Map<Long, TbWtExcessAmt> excessAmountData, Map<Long, DemandNotice> demandNotice, DemandNotice demandNoticeCharge,
				List<BillTaxDTO> taxAmountList1, List<Long> finYearListFromLastBillGenDate, List<TbWtBillMasEntity> billGenerated,
				List<TbBillMas> currentnotPaidBills, Map<Long, TbTaxMas> taxes, int langId, AtomicDouble interestValue,
				Map<Long, SMSAndEmailDTO> smsEmailMap, Map<Long, List<TbBillMas>> notPaidBills, int monthCount, Long finYear,
				Set<Long> connectionids, Map<Long, List<AdjustmentMasterEntity>> adjustmentEntry, int cycleLength, String remarks,
				String ipAddress, Long empId) {

		 	LOGGER.info("calculateTaxesAndGenerateBill");
	    	try {
	    		// for each connection tax wise loop is going
	            for (final TbTaxMas taxMas : taxList) {
	            	//#135897 changes for interest calculation for ASCL Project
	            	final LookUp lookUp = CommonMasterUtility.getNonHierarchicalLookUpObject(waterDTO.getCsCcnsize(), organisation);
	            	String ccnTyp = lookUp.getLookUpCode().equals(PrefixConstants.NewWaterServiceConstants.SWR) ? PrefixConstants.NewWaterServiceConstants.CCN_TYP_SEWER : 
	                	NewWaterServiceConstants.CCN_TYP_WTR ;
	            	if (Utility.isEnvPrefixAvailable(organisation, MainetConstants.ENV_ASCL)) {
	            	if (taxMas.getTaxDesc().toUpperCase().contains(ccnTyp)) {
	            	
	                LookUp taxType = CommonMasterUtility.getNonHierarchicalLookUpObject(
	                        Long.valueOf(taxMas.getTaxMethod()), organisation);
	                LookUp taxCategory1 = CommonMasterUtility
	                        .getHierarchicalLookUp(taxMas.getTaxCategory1(), organisation);

	    			if (!PrefixConstants.TAX_CATEGORY.ADVANCE.equals(taxCategory1.getLookUpCode())
	    					&& !PrefixConstants.TAX_CATEGORY.NOTICE
	    							.equals(taxCategory1.getLookUpCode()) && !PrefixConstants.TAX_CATEGORY.PENALTY
	    							.equals(taxCategory1.getLookUpCode())) {

	                    WaterRateMaster rateMaster = (WaterRateMaster) rateMasterInit.clone();
	                    WaterTaxCalculation taxCalculation = (WaterTaxCalculation) taxCalculationInit.clone();
	                    setMeterNonMeterData(waterDTO, meter, errorDto, errorListMap, organisation,
	                            rateMaster, taxCalculation, meterType, billingMethodDesc);
	                    rateMaster.setChargeApplicableAt(chargeApplicableAt.getDescLangFirst());
	                    waterRateMap.put(taxMas.getTaxId(),
	                            populateRateMasterModel(waterDTO, taxMas, taxCategory1, taxType,
	                            		organisation, rateMaster, billSchedule));

	                    if (PrefixConstants.TAX_CATEGORY.INTERST
	                            .equals(taxCategory1.getLookUpCode())) {
	                        interestTaxDto = new BillTaxDTO();
	                        interestTaxDto.setTaxCategoryCodeValue(taxCategory1.getLookUpCode());
	                        interestTaxDto.setTaxId(taxMas.getTaxId());
	                        interestTaxDto.setTaxSequence(taxMas.getCollSeq());
	                        interestTaxDto.setTaxCategory(taxMas.getTaxCategory1());
	                        interestTaxDto.setTaxSubCategory(taxMas.getTaxCategory2());
	                        interestTaxId = taxMas.getTaxId();
	                    }
	                    // Telescopic case calculation is in JAVA for other case it in Rule
	                    // Sheet-Tax Calculation
	                    else if (!PrefixConstants.TAX_TYPE.TELESCOPIC
	                            .equals(taxType.getLookUpCode())) {
	                        taxCalculation.setTaxCategory(taxCategory1.getLookUpCode());

	                        // calculation in map
	                        taxCalculationMap.put(taxMas.getTaxId(), populateTaxCalculationModel(
	                                waterDTO, taxMas, taxType, organisation, taxCalculation));
	                    }
	                }
	                // only setting calculated amount
	                else if (PrefixConstants.TAX_CATEGORY.ADVANCE
	                        .equals(taxCategory1.getLookUpCode())) {
	                    excessAmount = excessAmountData.get(waterDTO.getCsIdn());
	                    if (excessAmount != null) {
	                        // just setting the dto
	                        setTaxCalculationDto(taxMas, waterDTO.getCsIdn(), taxAmountList1,
	                                excessAmount.getExcAmt(), taxCategory1.getLookUpCode(), null,
	                                0d);
	                    }
	                }
	                // only setting calcualted amount
	                else if (PrefixConstants.TAX_CATEGORY.NOTICE
	                        .equals(taxCategory1.getLookUpCode())) {
	                    demandNoticeCharge = demandNotice.get(waterDTO.getCsIdn());
	                    if ((demandNoticeCharge != null)
	                            && demandNoticeCharge.getTaxCode().equals(taxMas.getTaxCode())) {
	                        demandNoticeCharge.setIsDeleted(MainetConstants.YES);
	                        setTaxCalculationDto(taxMas, waterDTO.getCsIdn(), taxAmountList1,
	                                demandNoticeCharge.getTaxAmount(), taxCategory1.getLookUpCode(),
	                                null, 0d);
	                    }
	                }
	                taxes.put(taxMas.getTaxId(), taxMas);
	            	}
	            }else {
	            LookUp taxType = CommonMasterUtility.getNonHierarchicalLookUpObject(
	                        Long.valueOf(taxMas.getTaxMethod()), organisation);
	                LookUp taxCategory1 = CommonMasterUtility
	                        .getHierarchicalLookUp(taxMas.getTaxCategory1(), organisation);

	    			if (!PrefixConstants.TAX_CATEGORY.ADVANCE.equals(taxCategory1.getLookUpCode())
	    					&& !PrefixConstants.TAX_CATEGORY.NOTICE
	    							.equals(taxCategory1.getLookUpCode()) && !PrefixConstants.TAX_CATEGORY.PENALTY
	    							.equals(taxCategory1.getLookUpCode())) {

	                    WaterRateMaster rateMaster = (WaterRateMaster) rateMasterInit.clone();
	                    WaterTaxCalculation taxCalculation = (WaterTaxCalculation) taxCalculationInit
	                            .clone();
	                    setMeterNonMeterData(waterDTO, meter, errorDto, errorListMap, organisation,
	                            rateMaster, taxCalculation, meterType, billingMethodDesc);
	                    rateMaster.setChargeApplicableAt(chargeApplicableAt.getDescLangFirst());
	                    waterRateMap.put(taxMas.getTaxId(),
	                            populateRateMasterModel(waterDTO, taxMas, taxCategory1, taxType,
	                                    organisation, rateMaster, billSchedule));

	                    if (PrefixConstants.TAX_CATEGORY.INTERST
	                            .equals(taxCategory1.getLookUpCode())) {
	                        interestTaxDto = new BillTaxDTO();
	                        interestTaxDto.setTaxCategoryCodeValue(taxCategory1.getLookUpCode());
	                        interestTaxDto.setTaxId(taxMas.getTaxId());
	                        interestTaxDto.setTaxSequence(taxMas.getCollSeq());
	                        interestTaxDto.setTaxCategory(taxMas.getTaxCategory1());
	                        interestTaxDto.setTaxSubCategory(taxMas.getTaxCategory2());
	                        interestTaxId = taxMas.getTaxId();
	                    }
	                    // Telescopic case calculation is in JAVA for other case it in Rule
	                    // Sheet-Tax Calculation
	                    else if (!PrefixConstants.TAX_TYPE.TELESCOPIC
	                            .equals(taxType.getLookUpCode())) {
	                        taxCalculation.setTaxCategory(taxCategory1.getLookUpCode());

	                        // calculation in map
	                        taxCalculationMap.put(taxMas.getTaxId(), populateTaxCalculationModel(
	                                waterDTO, taxMas, taxType, organisation, taxCalculation));
	                    }
	                }
	                // only setting calculated amount
	                else if (PrefixConstants.TAX_CATEGORY.ADVANCE
	                        .equals(taxCategory1.getLookUpCode())) {
	                    excessAmount = excessAmountData.get(waterDTO.getCsIdn());
	                    if (excessAmount != null) {
	                        // just setting the dto
	                        setTaxCalculationDto(taxMas, waterDTO.getCsIdn(), taxAmountList1,
	                                excessAmount.getExcAmt(), taxCategory1.getLookUpCode(), null,
	                                0d);
	                    }
	                }
	                // only setting calcualted amount
	                else if (PrefixConstants.TAX_CATEGORY.NOTICE
	                        .equals(taxCategory1.getLookUpCode())) {
	                    demandNoticeCharge = demandNotice.get(waterDTO.getCsIdn());
	                    if ((demandNoticeCharge != null)
	                            && demandNoticeCharge.getTaxCode().equals(taxMas.getTaxCode())) {
	                        demandNoticeCharge.setIsDeleted(MainetConstants.YES);
	                        setTaxCalculationDto(taxMas, waterDTO.getCsIdn(), taxAmountList1,
	                                demandNoticeCharge.getTaxAmount(), taxCategory1.getLookUpCode(),
	                                null, 0d);
	                    }
	                }
	                taxes.put(taxMas.getTaxId(), taxMas);		            	
	             }
	            }
	            final Long interestTax = interestTaxId;
	            // all calculation MAP is created and send to BRMS call to avoid multiple
	            // call
	            rateMasterAndTaxCalculationBRMS(organisation, waterDTO, taxAmountList1, waterRateMap,
	    						taxCalculationMap, interestValue, taxes, interestTax, cycleLength);

	    				if (taxAmountList1 != null && !taxAmountList1.isEmpty()) {
	    					
	    					final Date dueDate = Utility.isEnvPrefixAvailable(organisation, MainetConstants.ENV_SKDCL)?
	    							new Date(new Date().getTime() + STD_DUE_DATE) : 
	    							getBillDueDate(organisation, meterType.getLookUpCode(), meter);
	    					/*
	    					 * In First Iteration(For monthCount == 0) it will take unpaid bills from
	    					 * Fetched unpaid bills and for next iteration if exist it will take the not
	    					 * paid bills from the bills currently generated as that are not exist in
	    					 * previously fetched not paid bills
	    					 */

	    					if (Utility.isEnvPrefixAvailable(organisation, MainetConstants.ENV_SKDCL)) {
	    						// to calculate actual arrears amount we need reference of unpaid bills
	    						if (MainetConstants.NewWaterServiceConstants.NON_METER
        								.equals(meterType.getLookUpCode())) {
        							if (finYearListFromLastBillGenDate.get(0).equals(finYear)) {
        								currentnotPaidBills.addAll(monthCount == 0
        										? notPaidBills.get(waterDTO.getCsIdn())
        										: getUnpaidBillEntityToDto(billGenerated));
        								notPaidBills.clear();
        							} else if (CollectionUtils.isEmpty(currentnotPaidBills) && CollectionUtils.isNotEmpty(billGenerated)) {
        								currentnotPaidBills.addAll(getUnpaidBillEntityToDto(billGenerated));
        							}
        						} else {
        							if(notPaidBills.get(waterDTO.getCsIdn())!=null) {
            							currentnotPaidBills.addAll(notPaidBills.get(waterDTO.getCsIdn()));
        							}
        						}
	    						
	    					} else {
	    						if (finYearListFromLastBillGenDate.get(0).equals(finYear)) {
	    							currentnotPaidBills = monthCount == 0 ? notPaidBills.get(waterDTO.getCsIdn())
	    									: getUnpaidBillEntityToDto(billGenerated);
	    						}
	    					}

	                // Now call Bill Generation
	    			billGenerated = billMasterService.billGeneartion(taxAmountList1, meter,
	                		waterDTO, interestValue.doubleValue(), remarks, organisation, langId,
	                        empId, excessAmount, interestTaxDto, dueDate, currentnotPaidBills,
	                        adjustmentEntry.get(waterDTO.getCsIdn()), finYear, ipAddress);
	                		connectionids.add(waterDTO.getCsIdn());
	                
	                smsEmailMap.put(waterDTO.getCsIdn(), setSmsEmailDto(waterDTO,
	                        billGenerated.get(billGenerated.size() - 1), empId));
	            } else {

	                // error message tax not calculated , rule not found

	                LOGGER.error("error message tax not calculated , rule not found");
	                final String errorMsg = ApplicationSession.getInstance()
	                        .getMessage("error message tax not calculated , rule not found");
	                setErrorMap(errorListMap, errorDto, waterDTO, errorMsg);

	            }
	    	}catch(Exception e) {
	    		LOGGER.error("Error in water tax calculation and bill generation of connection number ", waterDTO.getCsCcn() + " " + e.getMessage());
	  		    final String errorMsg = ApplicationSession.getInstance().getMessage("water.bill.error");
	  		    setErrorMap(errorListMap, errorDto, waterDTO, errorMsg);
	  		
			}
	    	return billGenerated;
		}
	 
	 private void calculatePenaltiesIncurredOnPrevBills(List<TbWtBillMasEntity> newbillsGenerated,
				List<TbBillMas> currentnotPaidBills, List<TbTaxMas> taxListNonMeter, Organisation orgnisation,
				AtomicLong selectedCount, Map<Long, WaterBillGenErrorDTO> errorListMap, TbCsmrInfoDTO waterDTO,
				List<TbCsmrInfoDTO> entitylist, WaterBillGenerationMap flowDto, Map<Long, SMSAndEmailDTO> smsEmailMap,
				int langId, Long empId, String ipAddress, List<Long> billNoList, List<Long> billIdListForVoucherPosting,
				Long finYearId, Long deptId, long startTime, Map<Long, List<AdjustmentMasterEntity>> adjustmentEntry) {

			List<TbWtBillMasEntity> prevInsertedBills = newbillsGenerated.stream()
					.filter(bills -> bills.getBmIdno() != 0l).collect(Collectors.toList());
			List<Long> prevInsertedBmIds =new ArrayList<>();
			prevInsertedBills.forEach(bill -> {
				prevInsertedBmIds.add(bill.getBmIdno());
			});
			
			// If new bills are Generated proceed to save that bills
			Boolean isPositiveAdjDone = false;
			List<AdjustmentBillDetailMappingEntity> mappingEntity = new ArrayList<>();
			if (!newbillsGenerated.isEmpty()) {
				LOGGER.info("If new bills are Generated proceed to save that bills");
				
				//Do positive adjustment before saving
				 if(Utility.isEnvPrefixAvailable(orgnisation, MainetConstants.ENV_SKDCL) 
						 && MainetConstants.WATER_DEPT.equals(departmentService.getDeptCode(deptId))) {
					 List<TbBillMas> newBills = new ArrayList<>();
					 newBills = getUnpaidBillEntityToDto(newbillsGenerated);
					 
					 List<AdjustmentMasterEntity> adjustments = adjustmentEntry.get(waterDTO.getCsIdn());
				 
					 if(adjustments!=null && !adjustments.isEmpty()) {
						 List<AdjustmentMasterEntity> adjustmentApplicable = adjustments.stream().filter(adj->
						 adj.getAdjType().equals(MainetConstants.MENU.P)).collect(Collectors.toList());
						 if(CollectionUtils.isNotEmpty(adjustmentApplicable)) {
							
							 mappingEntity = billMasterCommonService.
									 doAdjustmentForNewBill(newBills, adjustmentApplicable);
							 isPositiveAdjDone = true;
							 if ((mappingEntity != null) && !mappingEntity.isEmpty()) {
								 TbBillMas latestBillDTO = newBills.get(newBills.size()-1);
								 TbWtBillMasEntity latestBillToBeUpdated = newbillsGenerated.get(newbillsGenerated.size()-1);
								 for(TbBillDet dtoDetail: latestBillDTO.getTbWtBillDet()) {
									 for(TbWtBillDetEntity detEntity: latestBillToBeUpdated.getBillDetEntity()) {
										 if(dtoDetail.getTaxId().equals(detEntity.getTaxId())) {
											 detEntity.setBdCurBalTaxamt(dtoDetail.getBdCurBalTaxamt());
										 }
									 }
								 }
								 
								 latestBillToBeUpdated.setBmTotalBalAmount(latestBillDTO.getBmTotalBalAmount());
								 latestBillToBeUpdated.setBmTotalOutstanding(latestBillDTO.getBmTotalOutstanding());
							 }  
						 }
					 }
				 }
				//Cleared all adjustments before storing bill
				
			    List<TbWtBillMasEntity> bills = (List<TbWtBillMasEntity>) billMasterJpaRepository
		            .save(newbillsGenerated);
    		    if(isPositiveAdjDone) {
    			   //updating BD_BILLDETID in tb_adj_bill_details for reference
    			   List<TbBillMas> newBillsGen = getUnpaidBillEntityToDto(newbillsGenerated);
    			   for(TbBillDet billDet: newBillsGen.get(newBillsGen.size()-1).getTbWtBillDet()) {
    				   for (final AdjustmentBillDetailMappingEntity mapping : mappingEntity) {
    						if(mapping.getTaxId().equals(billDet.getTaxId())) {
    		        			   billMasterCommonService.updateMappingTable(billDet, mapping, orgnisation.getOrgid());
    						}
    				   }
    			   }
    		   }
				 
			    // Lambda loop replaced with forEach due to unable to create session inside
			    // lamba while calling sendEmail method.           
			    if(CollectionUtils.isEmpty(currentnotPaidBills)) {
			    	currentnotPaidBills = new ArrayList<>();
			    }
			    for (TbWtBillMasEntity billGen : bills) {
			        if (!MainetConstants.NewWaterServiceConstants.YES.equals(billGen.getFlagJvPost())) {
			        	if(!prevInsertedBmIds.contains(billGen.getBmIdno())) {
			        		billNoList.add(billGen.getBmIdno());
			        	}
			        	
			            if(Utility.comapreDates(billGen.getBmBilldt(), new Date())) {
			            	billIdListForVoucherPosting.add(billGen.getBmIdno());
			            }
			            
			            if(CollectionUtils.isNotEmpty(currentnotPaidBills)) {
			            	for (TbBillMas billMas : currentnotPaidBills) {
			             	   if(StringUtils.equals(billMas.getBmNo(), billGen.getBmNo())) {
			             		   billMas.setBmIdno(billGen.getBmIdno());
			             	   }
						}
			            }else {
			            	TbBillMas billMas = new TbBillMas();
			            	BeanUtils.copyProperties(billGen, billMas);
			            	currentnotPaidBills.add(billMas);
			            }		           		            
			        }
			    }
			   
				sendMail(orgnisation, langId,
						smsEmailMap.get((bills.get(bills.size() - 1)).getCsIdn()));

			    // Surcharge related code strats here		   
			    for (final TbTaxMas taxMas : taxListNonMeter) {
					LookUp taxCategory1 = CommonMasterUtility
							.getHierarchicalLookUp(taxMas.getTaxCategory1(), orgnisation);
					if (PrefixConstants.TAX_CATEGORY.PENALTY.equals(taxCategory1.getLookUpCode())) {
						if (Utility.isEnvPrefixAvailable(orgnisation, MainetConstants.ENV_SKDCL)) {

							TbServiceReceiptMasEntity receiptOfLatestPaidBill = iReceiptEntryService
									.getLatestReceiptDetailByAddRefNo(orgnisation.getOrgid(),
											String.valueOf(bills.get(0).getCsIdn()));
							Date manualReceiptDate = receiptOfLatestPaidBill != null ? receiptOfLatestPaidBill.getRmDate()
									: null;
							calculateSurcharge(orgnisation, deptId, currentnotPaidBills, taxMas, finYearId, waterDTO,
									ipAddress, empId, "Y", manualReceiptDate, null);

						} else if(Utility.isEnvPrefixAvailable(orgnisation, MainetConstants.ENV_PSCL)){
							calculateSurchargePSCL(orgnisation, deptId, currentnotPaidBills, taxMas, finYearId, waterDTO,
									ipAddress, empId, "Y", null);
						}else {
							calculateSurcharge(orgnisation, deptId, currentnotPaidBills, taxMas, finYearId, waterDTO,
									ipAddress, empId, "Y", null);
						}
					}
				}
			   //Commented save duplicate bill code
			   // Surcharge related code ends here		    
			   /*Map<Long, WaterBillPrintingDTO> billMasPrint = new HashMap<>(0);
			    String meter = CommonMasterUtility.findLookUpCode(
			            MainetConstants.NewWaterServiceConstants.WMN, orgnisation.getOrgid(),
			            entitylist.get(0).getCsMeteredccn());
			    List<String> billIds = billNoList.stream().map(list -> String.valueOf(list))
			            .collect(Collectors.toList());
				Map<Long, WaterBillPrintingDTO> printDtos = prinBillData(billMasPrint, orgnisation, billIds,
						meter, FileNetApplicationClient.getInstance(),taxesMasterForReceipt,waterDTO.getApplicationNo(),MainetConstants.FlagY,surchargeTaxId);
			    
				saveDuplicateBill(printDtos, orgnisation.getOrgid(), empId, ipAddress);*/
			}
					
			// count--;
			selectedCount.getAndDecrement();
			long endTime = System.currentTimeMillis();
			long duration = (endTime - startTime);  // Total execution time in milli seconds
			LOGGER.info("Time taken for one bill generation : " + duration + " MiliSecond");		
			setWaterBillGenerationMap(errorListMap, waterDTO, selectedCount, entitylist.size(), duration,flowDto);
			LOGGER.info("End--> " + this.getClass().getSimpleName() + " waterBillGeneration() method & Connection No. : "+waterDTO.getCsCcn());		
		}
	 
	    @Override
		public WaterBillPrintSkdclDTO setBillDataInDTO(List<Object[]> billMasList, Organisation organisation, Map<Long, WaterBillPrintSkdclDTO> 
			billMasPrint, List<TbBillDet> billDetList, List<String> billIds, List<Long> 
			connectionIds, Long surchargeTaxId) {
	    	WaterBillPrintSkdclDTO bill = null;
			if ((billMasList != null) && !billMasList.isEmpty()) {

                final Long deptId = departmentService.getDepartmentIdByDeptCode(MainetConstants.WATER_DEPT,
                        MainetConstants.STATUS.ACTIVE);	  
	            for (final Object[] billMas : billMasList) {
	                bill = new WaterBillPrintSkdclDTO();
	                bill.setConnectionNo(String.valueOf(billMas[1]));
	                Long csIdn = Long.valueOf(String.valueOf(billMas[43]));
                	TbCsmrInfoDTO csmrInfo = newWaterConnectionService.getConnectionDetailsById(csIdn);
	                Long meterTypeCode = csmrInfoReposiory.fetchMeterTypeByCsidn(csIdn, organisation.getOrgid());
	                final LookUp meterType = CommonMasterUtility
	                        .getNonHierarchicalLookUpObject(meterTypeCode, organisation);
	                TbWtBillMasEntity previousBill = null;
	                List<TbWtBillMasEntity> billMasByConnectionId = tbWtBillMasJpaRepository.getBillMasByConnectionId(csIdn);
	                if(billMasByConnectionId!=null && !billMasByConnectionId.isEmpty()) {
	                	
	                	if(billMasByConnectionId.size()>1) {
							//setting previous bill details
							previousBill = billMasByConnectionId.get(billMasByConnectionId.size()-2);
							bill.setPrevBillDate(previousBill.getBmBilldt()!=null ? new SimpleDateFormat(MainetConstants.DATE_FORMAT).format(previousBill.getBmBilldt()):
									StringUtils.EMPTY);
							bill.setPrevBillNo(previousBill.getBmNo());
							Double prevBillOutstandingAmt = previousBill.getBmTotalOutstanding();
							List<WaterPenaltyEntity> penaltyList = waterPenaltyRepository
									.getWaterPenaltyByCCnNo(billMas[23].toString(), organisation.getOrgid());
							double sumOfPenalty = penaltyList.stream().filter(billId-> billId.getBmIdNo() != 
									billMasByConnectionId.get(billMasByConnectionId.size()-1).getBmIdno()).mapToDouble(penalty->penalty.getPendingAmount()).sum();
								
							bill.setPrevBillAmount(String.valueOf(prevBillOutstandingAmt + sumOfPenalty));
	                	}
	                	
	                	TbWtBillMasEntity latestBill = billMasByConnectionId.get(billMasByConnectionId.size()-1);
	                	TbWtExcessAmt excessAmt = tbWtExcessAmtJpaRepository.findExcessAmountByCsIdnAndOrgId(Long.valueOf(csIdn),
	                            organisation.getOrgid());
	                	//Agreem shillak
	                	bill.setAdvanceAmount(excessAmt!=null? (excessAmt.getExcAmt()!=null? excessAmt.getExcAmt().doubleValue() : 0.0) : 0.0);
	                	List<TbTaxMas> findTaxesByDescAndOrgId = tbTaxMasService.findTaxesByDescAndOrgId(MainetConstants.ComparamMasterConstants.METER_RENT, organisation.getOrgid());
                		if(CollectionUtils.isNotEmpty(findTaxesByDescAndOrgId)) {
                			Optional<TbWtBillDetEntity> meterRentPresent = null;
                			for (TbTaxMas tax : findTaxesByDescAndOrgId) {
                				meterRentPresent = latestBill.getBillDetEntity().stream().filter(det-> det.getTaxId().equals(tax.getTaxId())).findAny();
                        		if(meterRentPresent.isPresent()) {
                    				bill.setMeterRent(Double.valueOf(Math.round(meterRentPresent.get().getBdCurBalTaxamt())));	
                            		break;
                        		}
                			}
                		}
	                } 
	                Integer familyMembersCount = 1;
	                if(billMas[35]!=null && billMas[35]!="") {
 	                	familyMembersCount = Integer.valueOf(String.valueOf(billMas[35]));
 		                bill.setNoOfFamilyMembers(familyMembersCount);
	                }
	                Double totalBalAmt = 0.0;
	                if(billMas[44]!=null && billMas[44]!="" ){
	                	totalBalAmt = Double.valueOf(String.valueOf(billMas[44]));
                	}
	                Double billBalAmt = billMas[41] !=null?  Double.valueOf(String.valueOf(billMas[41])) : 0.0;
					bill.setCurrentBillAmt(Double.valueOf(Math.round(billBalAmt)));
					
	                if(StringUtils.equals(meterType.getLookUpCode(), MainetConstants.NewWaterServiceConstants.METER)) {
	                	  List<TbMrdataEntity> meterData = tbMrdataJpaRepository.getMrDataByCsidnAndOrgId(
                			  csIdn, organisation.getOrgid());
	                	  
	                	if(CollectionUtils.isNotEmpty(meterData)) {
		                	TbMrdataEntity latestMeterData = meterData.get(0);
		                	bill.setMeterNo(String.valueOf(latestMeterData.getMrdId()));
		                	bill.setMeterReading(latestMeterData.getMrdMtrread());
		                	bill.setCurrentMeterReading(latestMeterData.getMrdMtrread());
		                	bill.setCurrentMeterReadingDate(latestMeterData.getMrdMrdate()!=null?
		                			new SimpleDateFormat(MainetConstants.DATE_FORMAT).format(latestMeterData.getMrdMrdate()) : StringUtils.EMPTY);
		                	bill.setPrevMeterReading(latestMeterData.getPreviousReading1());
		                	TbMeterMas tbMeterMas = null;
		                	Map<Long, TbMeterMas> findMeterMasListBycnsId = tbMasService.findMeterMasListBycnsId
		                			(Arrays.asList(csIdn), organisation.getOrgid());
		                	if(findMeterMasListBycnsId !=null && !findMeterMasListBycnsId.isEmpty()) {
		                		tbMeterMas = findMeterMasListBycnsId.get(csIdn);
		                	}
		                	bill.setMeterCost(tbMeterMas!=null ? (tbMeterMas.getMmMtrcost()!=null ? tbMeterMas.getMmMtrcost().doubleValue() : 0.0): 0.0);
		                	bill.setPrevReadingDate(meterData.size() >1 ? meterData.get(1).getMrdMrdate()!=null? 
		                			new SimpleDateFormat(MainetConstants.DATE_FORMAT).format(meterData.get(1).getMrdMrdate()) : StringUtils.EMPTY :
		                				StringUtils.EMPTY);
		                	bill.setConsumption(latestMeterData.getCsmp());
		                	bill.setGapCode(latestMeterData.getTbComparamDet().getCpdDesc());
		                	bill.setConnectionDate(latestMeterData.getTbCsmrInfo().getPcDate()!=null ? 
	                			new SimpleDateFormat(MainetConstants.DATE_FORMAT).format(latestMeterData.getTbCsmrInfo().getPcDate())
		                			: StringUtils.EMPTY);
		                	
		                	if(meterData.size() > 1) {
		                		TbMrdataEntity prevMeterReading = meterData.get(1);
		                		if(prevMeterReading!=null) {
			                		bill.setPrevReadingDate(prevMeterReading.getMrdMrdate()!=null?
			                				new SimpleDateFormat(MainetConstants.DATE_FORMAT).format(prevMeterReading.getMrdMrdate()) : StringUtils.EMPTY);
				                	bill.setPrevMeterReading(prevMeterReading.getMrdMtrread());
		                		}
		                	}
		                	
		    	            bill.setTariffAmount(Double.valueOf(Math.round(totalBalAmt/latestMeterData.getCsmp())));
                		}
	                }else if(StringUtils.equals(meterType.getLookUpCode(), MainetConstants.NewWaterServiceConstants.NON_METER) ) {
	                	if(csmrInfo.getPcDate()!=null) {
		                	bill.setConnectionDate(csmrInfo.getPcDate()!=null? 
	                			new SimpleDateFormat(MainetConstants.DATE_FORMAT).format(csmrInfo.getPcDate()) :
	                				StringUtils.EMPTY );
	                	}
	    	            bill.setTariffAmount(Double.valueOf(Math.round(totalBalAmt/(familyMembersCount * 6))));
	                }
					
	                bill.setBillNo(String.valueOf(billMas[0]));
	                if (billMas[2] != null) {
	                    final String conCategory = CommonMasterUtility.getCPDDescription(
	                            Long.valueOf(billMas[2].toString()), PrefixConstants.D2KFUNCTION.ENGLISH_DESC,
	                            organisation.getOrgid());
	                    bill.setTariffCategory(conCategory);
	                }
	                if (billMas[3] != null) {
	                    final String conSize = CommonMasterUtility.getCPDDescription(Long.valueOf(billMas[3].toString()),
	                            PrefixConstants.D2KFUNCTION.ENGLISH_DESC, organisation.getOrgid());
	                    bill.setConnectionSize(conSize);
	                }
	                if (billMas[4] != null) {
	                    final LookUp tariffCategory = CommonMasterUtility.getHierarchicalLookUp(
	                            Long.valueOf(billMas[4].toString()), organisation.getOrgid());
	                    bill.setTariffCategory(tariffCategory.getDescLangFirst());
	                }
	                
	                String address = billMas[9]!=null ? String.valueOf(billMas[9])+", " : "";
	                String flatNo = billMas[5]!=null ? String.valueOf(billMas[5])+", " : "";
	                String building = billMas[11]!=null? String.valueOf(billMas[11])+", " : "";
	                String lane = billMas[12]!=null? String.valueOf(billMas[12])+", " : "";
	                String road = billMas[13]!=null ? String.valueOf(billMas[13]) : "";
	                String pincode = "";
	                if(billMas[32] != null) {
	                	pincode = String.valueOf(billMas[32]);
	               }else if(billMas[38]!=null) {
	                	pincode = String.valueOf(billMas[38]);

	               }
	                bill.setAddress(address + flatNo + building + lane + road);
	                bill.setPincode(pincode);
	                String name = ((billMas[6]!=null ? String.valueOf(billMas[6])+" " : "") +
	                		(billMas[7]!=null ? String.valueOf(billMas[7])+" " : "" ) +
	                		(billMas[8]!=null ? String.valueOf(billMas[8]) : ""));
	                
	                bill.setName(name);
	                
	                bill.setPropertyNo(billMas[24] !=null ? String.valueOf(billMas[24]) : "");
	                bill.setMobileNo(billMas[27] !=null ? String.valueOf(billMas[27]) : "");
                    
	                bill.setBillGenerationDate(billMas[14] != null? 
	                		new SimpleDateFormat(MainetConstants.DATE_FORMAT).format((Date) billMas[14])
	                		: StringUtils.EMPTY);
	                if (billMas[15] != null &&  billMas[16] != null) {
	                   bill.setBillingCycle(new SimpleDateFormat(MainetConstants.DATE_FORMAT).format((Date) billMas[15])
                		   + " to " +  new SimpleDateFormat(MainetConstants.DATE_FORMAT).format((Date) billMas[16]));
	                }
                	bill.setBillDueDate(billMas[17] != null? 
                		new SimpleDateFormat(MainetConstants.DATE_FORMAT).format((Date) billMas[17])
                			: StringUtils.EMPTY);
	               
	                bill.setBillNo(billMas[25] !=null? String.valueOf(billMas[25]):"");

	                if(billMas[45]!=null) {
	                	 bill.setWard(CommonMasterUtility.getHierarchicalLookUp(Long.valueOf(String.valueOf(billMas[45])),
	 	                		organisation.getOrgid()).getDescLangFirst());
	                }
	                if(billMas[34]!=null) {
	                	 bill.setZone(CommonMasterUtility.getHierarchicalLookUp(Long.valueOf(String.valueOf(billMas[34])),
	 	                		organisation.getOrgid()).getDescLangSecond());
	                }
	               
	                bill.setOldConnNo(billMas[36] !=null? String.valueOf(billMas[36]) : "");
	                
	                if(billMas[37]!=null) {
	                	 final LookUp tariffSubCategory = CommonMasterUtility.getHierarchicalLookUp(
	                             Long.valueOf(billMas[37].toString()), organisation.getOrgid());
	 	                bill.setTariffSubCategory(tariffSubCategory.getDescLangFirst());
	 	                 	
	                }
	                List<TbBillMas> billList = billMasterService.getBillMasterListByUniqueIdentifier(csIdn, organisation.getOrgid());
	                Double adjustmentAmountForWaterSkdcl = billMasterService.getAdjustmentAmountForWaterSkdcl(deptId, csIdn, organisation.getOrgid(), billList);
                	bill.setAdjustmentAmt(adjustmentAmountForWaterSkdcl!=null? adjustmentAmountForWaterSkdcl : 0.0);

					List<WaterPenaltyEntity> penaltyList = waterPenaltyRepository
							.getWaterPenaltyByCCnNo(billMas[23].toString(), organisation.getOrgid());
					double sumOfPenalty = 0.00;
					for (WaterPenaltyEntity penalty : penaltyList) {
						sumOfPenalty += Math.round(penalty.getPendingAmount());
					}
					bill.setPenalty(sumOfPenalty);
					
					bill.setArrearsAmt(String.valueOf(billMas[42])!=null? Math.round(Double.valueOf(String.valueOf(billMas[42]))):0d);
					
                	bill.setOutstandingAmount(bill.getArrearsAmt() + bill.getCurrentBillAmt()+ sumOfPenalty);
                	NumberToWordsConverter numToWords = new NumberToWordsConverter();
	                bill.setAmountInWords("Rupees " +numToWords.convert(bill.getOutstandingAmount()) +" only");
					
	                billMasPrint.put(Long.valueOf(billMas[0].toString()), bill);
	            }
	        }
			return bill;
			
		
		}

		@Override
		public Map<Long, WaterBillPrintSkdclDTO> printBillSkdcl(Map<Long, WaterBillPrintSkdclDTO> billMasPrint,
				Organisation organisation, List<String> billIds, String meterType,
				FileNetApplicationClient fileNetApplicationClient, List<TbTaxMas> taxesMaster, Long surchargeTaxId) {

			LOGGER.info("Begin--> " + this.getClass().getSimpleName() + " printBillSkdcl() method ");

	    	final List<Long> billPrintIds = new ArrayList<>(0);
	        final List<Long> connectionIds = new ArrayList<>(0);
	        for (final String id : billIds) {
	            billPrintIds.add(Long.valueOf(id.trim()));
	        }
	        LOGGER.info("billPrintIds size is : "+billPrintIds.size());
	        final HashMap<Long, String> taxDesc = new HashMap<>(0);

	        if ((taxesMaster != null) && !taxesMaster.isEmpty()) {
	            for (final TbTaxMas tax : taxesMaster) {
	                taxDesc.put(tax.getTaxId(), tax.getTaxDesc());
	            }
	        }
	        final List<Object[]> billMasList = getBillPrintingData(billPrintIds, organisation);
	        LOGGER.info("BillMasList size after getBillPrintingData() method is : "+billMasList.size());
	        final List<TbBillDet> billDetList = getBillDetailEntity(billPrintIds, organisation.getOrgid());
	        LOGGER.info("billDetList size after getBillDetailEntity() method is : "+billDetList.size());
	        
	        setBillDataInDTO(billMasList, organisation, billMasPrint, billDetList, billIds, connectionIds, surchargeTaxId);
	        
			return billMasPrint; 
		
		}

		@Override
		public Map<String, WaterBillPrintSkdclDTO> printDuplicateBill(Organisation organisation, Long csIdn, Long bmIdno,
				String selectedBillNo) {
			LOGGER.info("Begin--> " + this.getClass().getSimpleName() + " printDuplicateBill() method ");

			Map<String, WaterBillPrintSkdclDTO> billNoWiseBillHistory = new HashMap<>(0);

	        List<Object[]> duplicateBillData = getDuplicateBillData(organisation.getOrgid(), csIdn, bmIdno, selectedBillNo);
	    	WaterBillPrintSkdclDTO bill = null;

	        if(duplicateBillData != null && !duplicateBillData.isEmpty()) {
	        	final Long deptId = departmentService.getDepartmentIdByDeptCode(MainetConstants.WATER_DEPT,
        			MainetConstants.STATUS.ACTIVE);	
	        	Long meterTypeCode = csmrInfoReposiory.fetchMeterTypeByCsidn(csIdn, organisation.getOrgid());
                final LookUp meterType = CommonMasterUtility.getNonHierarchicalLookUpObject(meterTypeCode, organisation);
                List<TbMrdataEntity> meterData = null;
                if(StringUtils.equals(meterType.getLookUpCode(), MainetConstants.NewWaterServiceConstants.METER)) {
                	meterData = tbMrdataJpaRepository.getMrDataByCsidnAndOrgId(
	                		csIdn, organisation.getOrgid());
                }
                
                Object[] billMas = duplicateBillData.get(duplicateBillData.size()-1);
            	bill = new WaterBillPrintSkdclDTO();
            	bill.setConnectionNo(String.valueOf(billMas[1]));
            	TbCsmrInfoDTO csmrInfo = newWaterConnectionService.getConnectionDetailsById(csIdn);
                
                TbWtBillMasEntity previousBill = null;
                List<TbWtBillMasEntity> billMasByConnectionId = tbWtBillMasJpaRepository.getBillMasByConnectionId(csIdn);
                if(billMasByConnectionId!=null && !billMasByConnectionId.isEmpty()) {
                	if(billMasByConnectionId.size()>1) {
						//setting previous bill details
						previousBill = billMasByConnectionId.get(billMasByConnectionId.size()-1);
						bill.setPrevBillDate(previousBill.getBmBilldt() != null? 
		                		new SimpleDateFormat(MainetConstants.DATE_FORMAT).format(previousBill.getBmBilldt())
	                			: StringUtils.EMPTY);
						bill.setPrevBillNo(previousBill.getBmNo());
						WaterPenaltyEntity waterPenaltyByBmIdNo = waterPenaltyRepository.getWaterPenaltyByBmIdNo(String.valueOf(csIdn), bmIdno, organisation.getOrgid());
						bill.setPrevBillAmount(waterPenaltyByBmIdNo!=null ? String.valueOf(waterPenaltyByBmIdNo.getActualAmount()) : "0.0");
                	}
                	TbWtBillMasEntity latestBill = billMasByConnectionId.get(billMasByConnectionId.size()-1);
                	TbWtExcessAmt excessAmt = tbWtExcessAmtJpaRepository.findExcessAmountByCsIdnAndOrgId(Long.valueOf(csIdn),
                            organisation.getOrgid());
                	//Agreem shillak
                	bill.setAdvanceAmount(excessAmt!=null? (excessAmt.getExcAmt()!=null? excessAmt.getExcAmt().doubleValue() : 0d) : 0d);
                	List<TbTaxMas> findTaxesByDescAndOrgId = tbTaxMasService.findTaxesByDescAndOrgId(MainetConstants.ComparamMasterConstants.METER_RENT, organisation.getOrgid());
            		if(CollectionUtils.isNotEmpty(findTaxesByDescAndOrgId)) {
            			Optional<TbWtBillDetEntity> meterRentPresent = null;
            			for (TbTaxMas tax : findTaxesByDescAndOrgId) {
            				meterRentPresent = latestBill.getBillDetEntity().stream().filter(det-> det.getTaxId().equals(tax.getTaxId())).findAny();
                    		if(meterRentPresent.isPresent()) {
                				bill.setMeterRent(Double.valueOf(Math.round(meterRentPresent.get().getBdCurBalTaxamt())));	
                        		break;
                    		}
            			}
            		}	
                }	
                Integer familyMembersCount = 1;
                if(billMas[35]!=null && billMas[35]!="") {
                	familyMembersCount = Integer.valueOf(String.valueOf(billMas[35]));
	                bill.setNoOfFamilyMembers(familyMembersCount);
                }
                Double totalBalAmt = 0.0;
                if(billMas[44]!=null && billMas[44]!="" ) 
            	{
                	totalBalAmt = Double.valueOf(String.valueOf(billMas[44]));
            	}
                Double billBalAmt = billMas[41] !=null?  Double.valueOf(String.valueOf(billMas[41])) : 0.0;
				bill.setCurrentBillAmt(Double.valueOf(Math.round(billBalAmt)));
				
				if(StringUtils.equals(meterType.getLookUpCode(), MainetConstants.NewWaterServiceConstants.METER)) {
					if(CollectionUtils.isNotEmpty(meterData)) {
	                	TbMrdataEntity latestMeterData = meterData.get(0);
	                	bill.setMeterNo(String.valueOf(latestMeterData.getMrdId()));
	                	bill.setMeterReading(latestMeterData.getMrdMtrread());
	                	bill.setCurrentMeterReading(latestMeterData.getMrdMtrread());
	                	bill.setCurrentMeterReadingDate(latestMeterData.getMrdMrdate()!=null?
                			new SimpleDateFormat(MainetConstants.DATE_FORMAT).format(latestMeterData.getMrdMrdate()) : StringUtils.EMPTY); 
	                	bill.setPrevMeterReading(latestMeterData.getPreviousReading1()!=null ? latestMeterData.getPreviousReading1() : 0l);
	                	TbMeterMas tbMeterMas = null;
	                	Map<Long, TbMeterMas> findMeterMasListBycnsId = tbMasService.findMeterMasListBycnsId
	                			(Arrays.asList(csIdn), organisation.getOrgid());
	                	if(findMeterMasListBycnsId !=null && !findMeterMasListBycnsId.isEmpty()) {
	                		tbMeterMas = findMeterMasListBycnsId.get(csIdn);
	                	}
	                	bill.setMeterCost(tbMeterMas!=null ? (tbMeterMas.getMmMtrcost()!=null ? tbMeterMas.getMmMtrcost().doubleValue() : 0.0): 0.0);
	                	bill.setPrevReadingDate(meterData.size() > 1 ? 
                			new SimpleDateFormat(MainetConstants.DATE_FORMAT).format(meterData.get(1).getMrdMrdate()) : StringUtils.EMPTY);
	                	bill.setConsumption(latestMeterData.getCsmp());
	                	bill.setGapCode(latestMeterData.getTbComparamDet().getCpdDesc());
	                	bill.setConnectionDate(latestMeterData.getTbCsmrInfo().getPcDate()!=null ? 
                			new SimpleDateFormat(MainetConstants.DATE_FORMAT).format(latestMeterData.getTbCsmrInfo().getPcDate())
                				: StringUtils.EMPTY);
	                	
	                	if(meterData.size() > 1) {
	                		TbMrdataEntity prevMeterReading = meterData.get(1);
	                		if(prevMeterReading!=null) {
		                		bill.setPrevReadingDate(prevMeterReading.getMrdMrdate()!=null ? 
	                    			new SimpleDateFormat(MainetConstants.DATE_FORMAT).format(prevMeterReading.getMrdMrdate())
		                				: StringUtils.EMPTY);
			                	bill.setPrevMeterReading(prevMeterReading.getMrdMtrread());
	                		}
	                	}
	    	            bill.setTariffAmount(Double.valueOf(Math.round(totalBalAmt/latestMeterData.getCsmp())));
					}
				}else if(StringUtils.equals(meterType.getLookUpCode(), MainetConstants.NewWaterServiceConstants.NON_METER) ) {
                	if(csmrInfo.getPcDate()!=null) {
	                	bill.setConnectionDate(csmrInfo.getPcDate()!=null ? 
                			new SimpleDateFormat(MainetConstants.DATE_FORMAT).format(csmrInfo.getPcDate())
                				: StringUtils.EMPTY);
                	}
    	            bill.setTariffAmount(familyMembersCount!=null && familyMembersCount!=0 ?
    	            		Double.valueOf(Math.round(totalBalAmt/(familyMembersCount * 6))) : 0d);
                }
                bill.setBillNo(String.valueOf(billMas[0]));
                if (billMas[2] != null) {
                    final String conCategory = CommonMasterUtility.getCPDDescription(
                            Long.valueOf(billMas[2].toString()), PrefixConstants.D2KFUNCTION.ENGLISH_DESC,
                            organisation.getOrgid());
                    bill.setTariffCategory(conCategory);
                }
                if (billMas[3] != null) {
                    final String conSize = CommonMasterUtility.getCPDDescription(Long.valueOf(billMas[3].toString()),
                            PrefixConstants.D2KFUNCTION.ENGLISH_DESC, organisation.getOrgid());
                    bill.setConnectionSize(conSize);
                }
                if (billMas[4] != null) {
                    final LookUp tariffCategory = CommonMasterUtility.getHierarchicalLookUp(
                            Long.valueOf(billMas[4].toString()), organisation.getOrgid());
                    bill.setTariffCategory(tariffCategory.getDescLangFirst());
                }
                
                String address = billMas[9]!=null ? String.valueOf(billMas[9])+", " : "";
                String flatNo = billMas[5]!=null ? String.valueOf(billMas[5])+", " : "";
                String building = billMas[11]!=null? String.valueOf(billMas[11])+", " : "";
                String lane = billMas[12]!=null? String.valueOf(billMas[12])+", " : "";
                String road = billMas[13]!=null ? String.valueOf(billMas[13]) : "";
                String pincode = "";
                if(billMas[32] != null) {
                	pincode = String.valueOf(billMas[32]);
               }else if(billMas[38]!=null) {
                	pincode = String.valueOf(billMas[38]);

               }
                bill.setAddress(address + flatNo + building + lane + road);
                bill.setPincode(pincode);
                String name = ((billMas[6]!=null ? String.valueOf(billMas[6])+" " : "") +
                		(billMas[7]!=null ? String.valueOf(billMas[7])+" " : "" ) +
                		(billMas[8]!=null ? String.valueOf(billMas[8]) : ""));
                
                bill.setName(name);
                
                bill.setPropertyNo(billMas[24] !=null ? String.valueOf(billMas[24]) : "");
                bill.setMobileNo(billMas[27] !=null ? String.valueOf(billMas[27]) : "");
                bill.setBillGenerationDate(billMas[14]!=null ? 
        			new SimpleDateFormat(MainetConstants.DATE_FORMAT).format((Date) billMas[14])
        				: StringUtils.EMPTY);
                if (billMas[15] != null &&  billMas[16] != null) {
                   bill.setBillingCycle(new SimpleDateFormat(MainetConstants.DATE_FORMAT).format((Date) billMas[15])
                		   + " to " +  new SimpleDateFormat(MainetConstants.DATE_FORMAT).format((Date) billMas[16]));
	                	                }
            	bill.setBillDueDate(billMas[17]!=null ? 
        			new SimpleDateFormat(MainetConstants.DATE_FORMAT).format((Date) billMas[17])
        				: StringUtils.EMPTY);
               
                bill.setBillNo(billMas[25] !=null? String.valueOf(billMas[25]):"");

                if(billMas[45]!=null) {
                	 bill.setWard(CommonMasterUtility.getHierarchicalLookUp(Long.valueOf(String.valueOf(billMas[45])),
 	                		organisation.getOrgid()).getDescLangFirst());
                }
                if(billMas[34]!=null) {
                	 bill.setZone(CommonMasterUtility.getHierarchicalLookUp(Long.valueOf(String.valueOf(billMas[34])),
 	                		organisation.getOrgid()).getDescLangSecond());
                }
               
                bill.setOldConnNo(billMas[36] !=null? String.valueOf(billMas[36]) : "");
                
                final LookUp tariffSubCategory = CommonMasterUtility.getHierarchicalLookUp(
                        Long.valueOf(billMas[37].toString()), organisation.getOrgid());
                bill.setTariffSubCategory(tariffSubCategory.getDescLangFirst());
                
                List<TbBillMas> billList = billMasterService.getBillMasterListByUniqueIdentifier(csIdn, organisation.getOrgid());
                Double adjustmentAmountForWaterSkdcl = billMasterService.getAdjustmentAmountForWaterSkdcl(deptId, csIdn, organisation.getOrgid(), billList);
            	bill.setAdjustmentAmt(adjustmentAmountForWaterSkdcl!=null? adjustmentAmountForWaterSkdcl : 0.0);

				List<WaterPenaltyHistoryEntity> penaltyList = waterPenaltyRepository.findHistoryByBmIdNoCsIdnAndOrgId(
						String.valueOf(csIdn), Long.valueOf(billMas[0].toString()), organisation.getOrgid());
				Double penalty = CollectionUtils.isNotEmpty(penaltyList)? penaltyList.get(0).getActualAmount() : 0d;
				bill.setPenalty(penalty);
				
				bill.setArrearsAmt(String.valueOf(billMas[42])!=null? Math.round(Double.valueOf(String.valueOf(billMas[42]))):0d); 
				
            	bill.setOutstandingAmount(bill.getArrearsAmt() + bill.getCurrentBillAmt()+ penalty);
            	NumberToWordsConverter numToWords = new NumberToWordsConverter();
                bill.setAmountInWords("Rupees " +numToWords.convert(bill.getOutstandingAmount()) +" only");
				
                billNoWiseBillHistory.put(selectedBillNo, bill);
	        }
			return billNoWiseBillHistory;
		}

		 /*
	     * (non-Javadoc)
	     * @see com.abm.mainet.water.service.TbWtBillMasService#getBillPrintingData (java.util.List)
	     */
	    @Transactional(readOnly = true)
	    public List<Object[]> getDuplicateBillData(Long orgid, Long csIdn, Long bmIdno, String selectedBillNo) {
	    	List<Object[]> result = null;
	    	try {
	    		result = tbWtBillMasJpaRepository.getDuplicateBillPrintingData(orgid, selectedBillNo);
	    	}catch(Exception e) {
	    		LOGGER.error("Exception while fetching bill history details for csidn " + csIdn + " and bill no. "+ selectedBillNo);
	    		LOGGER.error(e.getMessage());
	    	}
	        return result;

	    }
	    
		@Override
	    public Boolean isBillUpToDateForGivenFinYear(List<TbWtBillMasEntity> billList, Long finYearId, Long meterType){
	    	LOGGER.info("Begin--> " + this.getClass().getSimpleName() + " getFinYearListFromLastBillGenDate() method ");
	    	Boolean isBillUpToDate = false;
	    	List<Long> finYearList = new ArrayList<Long>();

	    	if(CollectionUtils.isNotEmpty(billList)) {
	    		if(billList.get(billList.size()-1).getBmPaidFlag()!=null && 
    				billList.get(billList.size()-1).getBmPaidFlag().equals(MainetConstants.N_FLAG)) {
					LOGGER.info("Payment is not done for" + billList.get(0).getCsIdn());
	    			return isBillUpToDate;
	    		}
		    	Organisation organisation = new Organisation();
		    	organisation.setOrgid(billList.get(0).getOrgid());
		    	final LookUp connType = CommonMasterUtility.getNonHierarchicalLookUpObject(meterType, organisation);
		    	if(StringUtils.equals(connType.getLookUpCode(), MainetConstants.NewWaterServiceConstants.METER)) {
					List<TbMrdataEntity> mrDataByCsidnAndOrgId = meterReadingRepository.getMrDataByCsidnAndOrgId(billList.get(0).getCsIdn(), organisation.getOrgid());
					if(CollectionUtils.isNotEmpty(mrDataByCsidnAndOrgId)) {
						if(mrDataByCsidnAndOrgId.get(0).getBillGen().equals(MainetConstants.Y_FLAG)) {
							isBillUpToDate = true;
							return isBillUpToDate;
						}
					}else {
						LOGGER.info("Meter readings not present for csIdn " + billList.get(0).getCsIdn());
						return isBillUpToDate;
					}
	
		    	}else {
		    		TbWtBillMasEntity billmas = billList.get(billList.size() - 1);
					Long currentFinYearId = iFinancialYearService.getFinanceYearId(billmas.getBmTodt());
					if(!currentFinYearId.equals(finYearId)) {
						return isBillUpToDate;
					}
		    		List<FinancialYear> financeYearListFromGivenDate = iFinancialYearService.getFinanceYearListFromGivenDate(billmas.getOrgid(), billmas.getBmYear(), new Date());
		    		if (!financeYearListFromGivenDate.isEmpty()) {
		                finYearList = new ArrayList<>();
		                for (FinancialYear financialYearEach : financeYearListFromGivenDate) {
							if(currentFinYearId.equals(financialYearEach.getFaYear())) {
			                	 if(getMonthFromDate(new Date()) > 3 && getMonthFromDate(new Date()) < 10) {
			                		 isBillUpToDate = financialYearEach.getFaToDate().compareTo(billmas.getBmTodt()) > 0 ? true : false;
			                	 }else {
			                		 isBillUpToDate = financialYearEach.getFaToDate().compareTo(billmas.getBmTodt()) != 0 ? true : false;
			                	 }
							}
		                }
		            }
		    	}  	
	    	}else {
	    		finYearList.add(finYearId);
		    	return isBillUpToDate;  
	    	}
	    	LOGGER.info("End--> " + this.getClass().getSimpleName() + " getFinYearListFromLastBillGenDate() method ");
	    	return isBillUpToDate;    	
	    }
		
		public List<Long> getFinYearListFromLastBillGenDateOrPcDate(Long orgId, Long finYearId) {
			List<FinancialYear> financeYearListFromGivenDate = 
					iFinancialYearService.getFinanceYearListFromGivenDate(orgId, finYearId, new Date());
			List<Long> finYearList = new ArrayList<>();

			if (CollectionUtils.isNotEmpty(financeYearListFromGivenDate)) {
	            for (FinancialYear financialYearEach : financeYearListFromGivenDate) {
	                finYearList.add(financialYearEach.getFaYear());
	            }
	        }
	    	return finYearList;
		}
		
		@Override
	    @Transactional
		public WaterPenaltyDto calculateSurchargePSCL(Organisation organisation, Long deptId, List<TbBillMas> billMasList,
				TbTaxMas taxMas, Long finYearId, TbCsmrInfoDTO csmrInfoDto, String ipAddress, Long userId,String billGenFlag,Date manualReceiptDate) {
	    	LOGGER.info("Begin--> " + this.getClass().getSimpleName() + " calculateSurcharge() method ");
	        WaterPenaltyDto waterSurCharge = new WaterPenaltyDto();
	        WaterBillTaxDTO surchargeTaxDto = null;
	        Date dueDateCrossed = new Date();
	        int noOfMonthsSurcharge = 0;
	        List<WaterPenaltyDto> surchargeList = new ArrayList<WaterPenaltyDto>();
	        if(manualReceiptDate != null) {
	        	dueDateCrossed = manualReceiptDate;
	        }
	        int size = billMasList.size() - 1;
	        double totalArrear = 0;
	        
	        TbBillMas billMaster = null;
	        TbBillMas previousBillMas = null;
	        Long bmIdNo = 0L;
	        if (csmrInfoDto.getCsIdn() != 0) {
	        	if(Utility.isEnvPrefixAvailable(organisation, MainetConstants.ENV_PSCL)) {
	        		surchargeList=waterPenaltyService.getWaterPenaltyByBmNoIds(billMasList, organisation.getOrgid());
	    			LOGGER.info("Checking Surcharge Calculated aginst particular Bill");
	        	}
	        }
	        LOGGER.info("calculateSurcharge method ---> check for prefix start");
	        boolean covidActiveFlag = checkDaysExtendedCovidActive(organisation);
	        LOGGER.info("calculateSurcharge method ---> check for prefix ends");
	        
	        List<WaterPenaltyDto> collect =new ArrayList<WaterPenaltyDto>();
	        // If no surcharge is calculated for current fin year then inserting new entry
	        if(CollectionUtils.isNotEmpty(billMasList)) {
	    		for (TbBillMas billMas : billMasList) {
	    			if(Utility.isEnvPrefixAvailable(organisation, MainetConstants.ENV_PSCL)) {
	    				int daysBetweenDates = 0;
	    	            totalArrear=0;
	    				collect = surchargeList.stream()
	    						.filter(detail -> detail.getBmIdNo().equals(billMas.getBmIdno())).collect(Collectors.toList());
	    				if(CollectionUtils.isNotEmpty(collect) && collect.get(0).getActualAmount()!=0) {
	    					continue;
	    				}
	    				if (CollectionUtils.isNotEmpty(collect)) {
	    				//	WaterPenaltyDto surchargeDto = new WaterPenaltyDto();
	    					BeanUtils.copyProperties(collect.get(0), waterSurCharge);
	    					waterSurCharge.setArrearPenalty(waterSurCharge.getPendingAmount());
	    					boolean isUpdatePenaltyTableFlag = false;
	    					Date surchargeFromDate = null;
	    		     	}else {
	    		     		waterSurCharge=null;
	    		     	}
	    			}
	    			
	    			if (waterSurCharge == null){
						if(Utility.compareDate(billMas.getBmDuedate(), dueDateCrossed) && !Utility.comapreDates(billMas.getBmDuedate(), dueDateCrossed)) {
							if(covidActiveFlag) {
								LOGGER.info("calculateSurcharge method ---> get arrears if penalty save start");
								totalArrear = totalArrear + arrearAmountIfCovidActive(organisation, billMas, finYearId, dueDateCrossed);
								bmIdNo = billMas.getBmIdno();
								LOGGER.info("calculateSurcharge method ---> get arrears if penalty save ends");
							}
							else {
								totalArrear = totalArrear + billMas.getBmTotalBalAmount();
								bmIdNo = billMas.getBmIdno();
								if(billMas.getBmTotalBalAmount() > 0) {
									int monthsBetweenDates = monthsBetweenDates(billMas.getBmFromdt(), billMas.getBmTodt()) + 1;
									noOfMonthsSurcharge = noOfMonthsSurcharge + monthsBetweenDates;
								}
							}
							
							previousBillMas = billMaster;
							billMaster = billMas;
						}
	        	
	            if(billMaster != null && excludeLastBillAmount(billMaster, organisation, dueDateCrossed)) {
	            	totalArrear = totalArrear - billMaster.getBmTotalBalAmount();
	            	if(previousBillMas != null) {
	            		billMaster = previousBillMas;
	            		bmIdNo = billMaster.getBmIdno();
	            	}
	            }
	            if (totalArrear > 0) {
	                // Here fetching charges from BRMS Sheet and calculating
	                LOGGER.info("Starts Surcharge Calculation from BRMS Sheet");
	            	surchargeTaxDto = fetchSurCharge(organisation, deptId, totalArrear, taxMas, csmrInfoDto,noOfMonthsSurcharge);
	                // Here setting the data to save in penalty table
	                if (surchargeTaxDto != null) {
	                    waterSurCharge = new WaterPenaltyDto();
	                    waterSurCharge.setConnNo(String.valueOf(csmrInfoDto.getCsIdn()));
	                    waterSurCharge.setBmIdNo(bmIdNo);
	                    waterSurCharge.setCreateddate(new Date());
	                    waterSurCharge.setCretedBy(userId);
	                    waterSurCharge.setLgIpmac(ipAddress);
	                    waterSurCharge.setOrgId(organisation.getOrgid());
	                    waterSurCharge.setTaxId(surchargeTaxDto.getTaxId());
	                    waterSurCharge.setActualAmount(surchargeTaxDto.getTaxAmount());
	                    waterSurCharge.setPendingAmount(surchargeTaxDto.getTaxAmount());
	                    waterSurCharge.setActualArrrearAmount(totalArrear);
	                    if(billMaster != null) {
	                    	 waterSurCharge.setSurchargeFromDate(billMasList.get(0).getBmFromdt());
	                         waterSurCharge.setSurchargeToDate(billMaster.getBmTodt());
	                         waterSurCharge.setFinYearId(billMaster.getBmYear());
	                    }else {
	                    	 waterSurCharge.setFinYearId(finYearId);
	                    }
	                    if(StringUtils.isNotBlank(billGenFlag) && StringUtils.equals(billGenFlag, MainetConstants.FlagY)) {
	                    	waterSurCharge.setBillGenAmount(surchargeTaxDto.getTaxAmount());
	                    	waterSurCharge.setCurrBmIdNo(billMas.getBmIdno());
	                    	waterSurCharge.setBmIdNo(billMas.getBmIdno());
	                    
	                    final LookUp chargeApplicableAt = CommonMasterUtility.getValueFromPrefixLookUp(
	                            PrefixConstants.NewWaterServiceConstants.BILL, PrefixConstants.NewWaterServiceConstants.CAA, organisation);

	                    LookUp taxCategoryLookUp = CommonMasterUtility.getHieLookupByLookupCode("P",
	                            PrefixConstants.LookUpPrefix.TAC, 1, organisation.getOrgid());
	                    LookUp taxSubCategoryLookUp = CommonMasterUtility.getHieLookupByLookupCode("SC",
	                            PrefixConstants.LookUpPrefix.TAC, 2, organisation.getOrgid());
	                    Long taxIds = tbTaxMasService.getTaxId(chargeApplicableAt.getLookUpId(), organisation.getOrgid(), deptId,
	                            taxCategoryLookUp.getLookUpId(), taxSubCategoryLookUp.getLookUpId());

	                    Optional<TbBillDet> findFirst = billMas.getTbWtBillDet().stream().filter(detail -> detail.getTaxId().equals(taxIds))
	                            .findFirst();
	                    if (findFirst.isPresent()) {
	                        for (TbBillDet detail : billMas.getTbWtBillDet()) {
	                            final String taxCode = CommonMasterUtility
	                                    .getHierarchicalLookUp(detail.getTaxCategory(), organisation).getLookUpCode();
	                            if(detail.getTaxId().equals(taxIds)) {
	                                if (waterSurCharge != null) {
	                                    detail.setBdCurTaxamt(detail.getBdCurTaxamt() + waterSurCharge.getPendingAmount());
	                                    detail.setBdCurBalTaxamt(detail.getBdCurBalTaxamt() + waterSurCharge.getPendingAmount());
	                                }
	                            }
	                        }
	                        billMas.setTotalPenalty(billMas.getTotalPenalty()+waterSurCharge.getActualAmount());
	                    } 
	                    TbBillMas  currentBill = update(billMas);
	                    LOGGER.info("SurCharge Details saved Successfully");
	                    }
	                }
	            }
	        }
	        // if any bill generated after calculating surcharge for current financial year
	        // then updating the surcharge
	        else {
	        	Long lastBillSurBillId = waterSurCharge.getBmIdNo();
	        	if(Utility.isEnvPrefixAvailable(organisation, MainetConstants.ENV_PSCL)) {
	        		 lastBillSurBillId=0L; 
	          	}
	        	if (Utility.compareDate(billMas.getBmDuedate(), dueDateCrossed)
								&& !Utility.comapreDates(billMas.getBmDuedate(), dueDateCrossed)
								&& (((manualReceiptDate != null
										&& (((waterSurCharge.getBillGenAmount() != null)
												&& (waterSurCharge.getActualAmount() == waterSurCharge.getBillGenAmount()))
												|| (Utility.compareDate(waterSurCharge.getSurchargeToDate(),
														manualReceiptDate) && billMas.getBmIdno() > lastBillSurBillId))
										|| (manualReceiptDate != null
												&& (Utility.compareDate(manualReceiptDate,
														waterSurCharge.getSurchargeToDate()))
												&& waterSurCharge.getBillGenAmount() != null
												&& ((waterSurCharge.getBillGenAmount() != null) && (waterSurCharge
														.getActualAmount() == waterSurCharge.getBillGenAmount())))))
										|| (manualReceiptDate == null && billMas.getBmIdno() > lastBillSurBillId))) {
							if(covidActiveFlag) {
								LOGGER.info("calculateSurcharge method ---> get arrears if penalty update start");
								totalArrear = totalArrear + arrearAmountIfCovidActive(organisation, billMas, finYearId, dueDateCrossed);
								lastBillSurBillId = billMas.getBmIdno();
								LOGGER.info("calculateSurcharge method ---> get arrears if penalty update start");
							}
							else {
								totalArrear = totalArrear + billMas.getBmTotalBalAmount();
								lastBillSurBillId = billMas.getBmIdno();
								if(billMas.getBmTotalBalAmount() > 0) {
									int monthsBetweenDates = monthsBetweenDates(billMas.getBmFromdt(), billMas.getBmTodt()) + 1;
									noOfMonthsSurcharge = noOfMonthsSurcharge + monthsBetweenDates;
									
									
								}
							}
							previousBillMas = billMaster;
							billMaster = billMas;
						}
					
	           
	           if(billMaster != null && excludeLastBillAmount(billMaster, organisation, dueDateCrossed)) {
	           	totalArrear = totalArrear - billMaster.getBmTotalBalAmount();
	           	if(previousBillMas != null) {
	        		billMaster = previousBillMas;
	        		lastBillSurBillId = billMaster.getBmIdno();
	        	}
	           }
	            if (totalArrear > 0) {
	            	surchargeTaxDto = fetchSurCharge(organisation, deptId, totalArrear, taxMas, csmrInfoDto, noOfMonthsSurcharge); 
	         				
	                if (surchargeTaxDto != null) {
	                	waterSurCharge.setActualArrrearAmount(totalArrear);
	                	if(manualReceiptDate != null) {
	                		waterSurCharge.setActualAmount(surchargeTaxDto.getTaxAmount());
	                    	waterSurCharge.setPendingAmount(surchargeTaxDto.getTaxAmount());
	                	}else {
	            			waterSurCharge.setActualAmount(waterSurCharge.getActualAmount()+surchargeTaxDto.getTaxAmount());
	                    	waterSurCharge.setPendingAmount(waterSurCharge.getPendingAmount()+surchargeTaxDto.getTaxAmount());
	                	}
	                	
	                	 if(StringUtils.isNotBlank(billGenFlag) && StringUtils.equals(billGenFlag, MainetConstants.FlagY)) {
	                		 if(waterSurCharge.getBillGenAmount() != null) {
	                			 waterSurCharge.setBillGenAmount(waterSurCharge.getBillGenAmount() + surchargeTaxDto.getTaxAmount());
	                			 waterSurCharge.setCurrBmIdNo(billMasList.get(billMasList.size() - 1).getBmIdno());
	                		 }else {
	                			 waterSurCharge.setBillGenAmount(surchargeTaxDto.getTaxAmount());
	                		 }
	                     }
	                	 // Here setting the data to update in penalty table
	                     waterSurCharge.setCurrBmIdNo(waterSurCharge.getBmIdNo());
	                     waterSurCharge.setUpdatedBy(userId);
	                     waterSurCharge.setLgIpMacUpd(ipAddress);
	                     if(billMaster != null && billMaster.getBmYear() != null) {
	                     	waterSurCharge.setFinYearId(billMaster.getBmYear());
	                     }
	                     if(billMaster != null) {
	                     	waterSurCharge.setSurchargeFromDate(waterSurCharge.getSurchargeToDate());
	                        waterSurCharge.setSurchargeToDate(billMaster.getBmTodt());
	                     }
	                     if(StringUtils.isNotBlank(billGenFlag) && StringUtils.equals(billGenFlag, MainetConstants.FlagY)) {
	                    	 
	                    	   final LookUp chargeApplicableAt = CommonMasterUtility.getValueFromPrefixLookUp(
	   	                            PrefixConstants.NewWaterServiceConstants.BILL, PrefixConstants.NewWaterServiceConstants.CAA, organisation);

	   	                    LookUp taxCategoryLookUp = CommonMasterUtility.getHieLookupByLookupCode("P",
	   	                            PrefixConstants.LookUpPrefix.TAC, 1, organisation.getOrgid());
	   	                    LookUp taxSubCategoryLookUp = CommonMasterUtility.getHieLookupByLookupCode("SC",
	   	                            PrefixConstants.LookUpPrefix.TAC, 2, organisation.getOrgid());
	   	                    Long taxIds = tbTaxMasService.getTaxId(chargeApplicableAt.getLookUpId(), organisation.getOrgid(), deptId,
	   	                            taxCategoryLookUp.getLookUpId(), taxSubCategoryLookUp.getLookUpId());
	   	                    
	   	                 Optional<TbBillDet> findFirst = billMas.getTbWtBillDet().stream().filter(detail -> detail.getTaxId().equals(taxIds))
		                            .findFirst();
	                    	   if (findFirst.isPresent()) {
	   	                        for (TbBillDet detail : billMas.getTbWtBillDet()) {
	   	                            final String taxCode = CommonMasterUtility
	   	                                    .getHierarchicalLookUp(detail.getTaxCategory(), organisation).getLookUpCode();
	   	                            if (StringUtils.equals(taxCode, "P")) {
	   	                                if (waterSurCharge != null) {
	   	                                    detail.setBdCurTaxamt(detail.getBdCurTaxamt() + waterSurCharge.getPendingAmount());
	   	                                    detail.setBdCurBalTaxamt(detail.getBdCurBalTaxamt() + waterSurCharge.getPendingAmount());
	   	                                }
	   	                            }
	   	                        }
	   	                        billMas.setTotalPenalty(billMas.getTotalPenalty()+waterSurCharge.getActualAmount());
		                    } 
		                    TbBillMas  currentBill = update(billMas);
		                     LOGGER.info("SurCharge Details Updated Successfully");
	                     }
	                }
	            }
	            
	          }
	    			}//
	    		
	    	}//
	        LOGGER.info("End--> " + this.getClass().getSimpleName() + " calculateSurcharge() method ");
	        return waterSurCharge;
	    }

}